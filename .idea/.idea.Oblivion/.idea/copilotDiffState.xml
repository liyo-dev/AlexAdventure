<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/GameBootService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/GameBootService.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;/// &lt;summary&gt;&#10;/// Servicio simple que hace persistir el GameBootProfile entre escenas&#10;/// Su única función es actuar como contenedor estático del ScriptableObject&#10;/// &lt;/summary&gt;&#10;public class GameBootService : MonoBehaviour&#10;{&#10;    [Header(&quot;Boot Profile&quot;)]&#10;    [SerializeField] private GameBootProfile bootProfile;&#10;    &#10;    // Cache estático para acceso global&#10;    private static GameBootProfile _profile;&#10;    private static bool _isInitialized = false;&#10;    &#10;    // Evento para notificar cuando el profile está listo&#10;    public static event System.Action OnProfileReady;&#10;    &#10;    // Propiedad pública para acceder al profile desde cualquier lugar&#10;    public static GameBootProfile Profile =&gt; _profile;&#10;    &#10;    void Awake()&#10;    {&#10;        // Si ya tenemos el profile cacheado, destruir este GameObject (evita duplicados)&#10;        if (_isInitialized)&#10;        {&#10;            Debug.Log(&quot;[GameBootService] Profile ya está inicializado. Destruyendo duplicado.&quot;);&#10;            Destroy(gameObject);&#10;            return;&#10;        }&#10;        &#10;        // Validar que tenemos el profile asignado&#10;        if (bootProfile == null)&#10;        {&#10;            Debug.LogError(&quot;[GameBootService] No se ha asignado GameBootProfile en el inspector!&quot;);&#10;            Destroy(gameObject);&#10;            return;&#10;        }&#10;        &#10;        // Cachear el profile para acceso global&#10;        _profile = bootProfile;&#10;        _isInitialized = true;&#10;        &#10;        // Hacer que este GameObject persista entre escenas&#10;        DontDestroyOnLoad(gameObject);&#10;        &#10;        Debug.Log($&quot;[GameBootService] GameBootProfile '{bootProfile.name}' cacheado y servicio persistente.&quot;);&#10;        &#10;        // Notificar que el profile está listo&#10;        OnProfileReady?.Invoke();&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Verifica si el GameBootProfile está disponible&#10;    /// &lt;/summary&gt;&#10;    public static bool IsAvailable =&gt; _profile != null &amp;&amp; _isInitialized;&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;/// &lt;summary&gt;&#10;/// Servicio simple que hace persistir el GameBootProfile entre escenas&#10;/// Su única función es actuar como contenedor estático del ScriptableObject&#10;/// &lt;/summary&gt;&#10;public class GameBootService : MonoBehaviour&#10;{&#10;    [Header(&quot;Boot Profile&quot;)]&#10;    [SerializeField] private GameBootProfile bootProfile;&#10;    &#10;    // Cache estático para acceso global&#10;    private static GameBootProfile _profile;&#10;    private static bool _isInitialized = false;&#10;    &#10;    // Evento para notificar cuando el profile está listo&#10;    public static event System.Action OnProfileReady;&#10;    &#10;    // Propiedad pública para acceder al profile desde cualquier lugar&#10;    public static GameBootProfile Profile =&gt; _profile;&#10;    &#10;    void Awake()&#10;    {&#10;        // Si ya tenemos el profile cacheado, destruir este GameObject (evita duplicados)&#10;        if (_isInitialized)&#10;        {&#10;            Debug.Log(&quot;[GameBootService] Profile ya está inicializado. Destruyendo duplicado.&quot;);&#10;            Destroy(gameObject);&#10;            return;&#10;        }&#10;        &#10;        // Validar que tenemos el profile asignado&#10;        if (bootProfile == null)&#10;        {&#10;            Debug.LogError(&quot;[GameBootService] No se ha asignado GameBootProfile en el inspector!&quot;);&#10;            Destroy(gameObject);&#10;            return;&#10;        }&#10;        &#10;        // Cachear el profile para acceso global&#10;        _profile = bootProfile;&#10;        _isInitialized = true;&#10;        &#10;        // Hacer que este GameObject persista entre escenas&#10;        DontDestroyOnLoad(gameObject);&#10;        &#10;        Debug.Log($&quot;[GameBootService] GameBootProfile '{bootProfile.name}' cacheado y servicio persistente.&quot;);&#10;&#10;        // Preparar el runtimePreset según reglas: preset de test -&gt; save -&gt; default&#10;        PrepareActivePreset();&#10;        &#10;        // Notificar que el profile está listo&#10;        OnProfileReady?.Invoke();&#10;    }&#10;&#10;    private void PrepareActivePreset()&#10;    {&#10;        var profile = _profile;&#10;        if (profile == null) return;&#10;&#10;        // Intentar localizar un SaveSystem en escena (persistente)&#10;        SaveSystem saveSystem = null;&#10;#if UNITY_2022_3_OR_NEWER&#10;        saveSystem = Object.FindFirstObjectByType&lt;SaveSystem&gt;(FindObjectsInactive.Include);&#10;#else&#10;#pragma warning disable 618&#10;        saveSystem = FindObjectOfType&lt;SaveSystem&gt;(true);&#10;#pragma warning restore 618&#10;#endif&#10;&#10;        bool initialized = false;&#10;&#10;        // 1) Forzar preset de test si está configurado&#10;        if (profile.ShouldBootFromPreset())&#10;        {&#10;            profile.EnsureRuntimePresetFromTemplate(profile.bootPreset);&#10;            Debug.Log(&quot;[GameBootService] Inicializado desde bootPreset (testing)&quot;);&#10;            initialized = true;&#10;        }&#10;        // 2) Intentar cargar partida si existe&#10;        else if (saveSystem &amp;&amp; saveSystem.HasSave())&#10;        {&#10;            if (profile.LoadProfile(saveSystem))&#10;            {&#10;                Debug.Log(&quot;[GameBootService] Inicializado desde SAVE&quot;);&#10;                initialized = true;&#10;            }&#10;        }&#10;&#10;        // 3) Si no, usar preset por defecto&#10;        if (!initialized)&#10;        {&#10;            if (profile.defaultPlayerPreset)&#10;            {&#10;                profile.EnsureRuntimePresetFromTemplate(profile.defaultPlayerPreset);&#10;                Debug.Log(&quot;[GameBootService] Inicializado desde defaultPlayerPreset&quot;);&#10;            }&#10;            else&#10;            {&#10;                profile.EnsureRuntimePreset();&#10;                Debug.LogWarning(&quot;[GameBootService] No hay defaultPlayerPreset. Se crea runtimePreset vacío.&quot;);&#10;            }&#10;        }&#10;&#10;        // Log rápido de diagnóstico&#10;        var p = profile.GetActivePresetResolved();&#10;        if (p)&#10;        {&#10;            Debug.Log($&quot;[GameBootService] RuntimePreset listo → Anchor: {p.spawnAnchorId}, HP: {p.currentHP}/{p.maxHP}, MP: {p.currentMP}/{p.maxMP}, Slots: L:{p.leftSpellId} R:{p.rightSpellId} S:{p.specialSpellId}&quot;);&#10;        }&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Verifica si el GameBootProfile está disponible&#10;    /// &lt;/summary&gt;&#10;    public static bool IsAvailable =&gt; _profile != null &amp;&amp; _isInitialized;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/PlayerPresetService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/PlayerPresetService.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;[DefaultExecutionOrder(-50)]&#10;[DisallowMultipleComponent]&#10;public class PlayerPresetService : MonoBehaviour&#10;{&#10;    [Header(&quot;Librería de hechizos (ID → SO)&quot;)]&#10;    [SerializeField] private SpellLibrarySO spellLibrary;&#10;&#10;    [Header(&quot;Opciones&quot;)]&#10;    [SerializeField] private bool autoFillEmptySlotsFromUnlocked; // default false por defecto&#10;    [SerializeField] private GameObject instigatorOverride;&#10;&#10;    MagicProjectileSpawner _spawner;&#10;    &#10;    // Evitar inicialización doble si el evento llega más de una vez o ya está listo al habilitar&#10;    bool _initialized;&#10;&#10;    void Awake()&#10;    {&#10;        _spawner = GetComponent&lt;MagicProjectileSpawner&gt;() ?? gameObject.AddComponent&lt;MagicProjectileSpawner&gt;();&#10;    }&#10;&#10;    // Suscribirnos al evento y cubrir el caso de que ya esté disponible&#10;    void OnEnable()&#10;    {&#10;        GameBootService.OnProfileReady += HandleProfileReady;&#10;        if (GameBootService.IsAvailable)&#10;        {&#10;            HandleProfileReady();&#10;        }&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;        GameBootService.OnProfileReady -= HandleProfileReady;&#10;    }&#10;&#10;    private void HandleProfileReady()&#10;    {&#10;        if (_initialized) return;&#10;        InitializePresetService();&#10;        _initialized = true;&#10;        // Ya no necesitamos el evento tras inicializar&#10;        GameBootService.OnProfileReady -= HandleProfileReady;&#10;    }&#10;&#10;    private void InitializePresetService()&#10;    {&#10;        var profile = GameBootService.Profile;&#10;        &#10;        if (!profile || !spellLibrary) &#10;        { &#10;            enabled = false; &#10;            Debug.LogError(&quot;[PlayerPresetService] Falta GameBootProfile o SpellLibrary.&quot;); &#10;            return; &#10;        }&#10;&#10;        var preset = profile.GetActivePresetResolved();&#10;        if (!preset) &#10;        { &#10;            Debug.LogWarning(&quot;[PlayerPresetService] Sin preset activo.&quot;); &#10;            return; &#10;        }&#10;&#10;        // USAR EL ANCHOR DEL PRESET SO&#10;        if (!string.IsNullOrEmpty(preset.spawnAnchorId))&#10;        {&#10;            SpawnManager.SetCurrentAnchor(preset.spawnAnchorId);&#10;        }&#10;&#10;        // Configurar hechizos del preset&#10;        ConfigureSpells(preset);&#10;    }&#10;&#10;    private void ConfigureSpells(PlayerPresetSO preset)&#10;    {&#10;        // Resolver IDs respetando None&#10;        var leftId = preset.leftSpellId;&#10;        var rightId = preset.rightSpellId;&#10;        var specialId = preset.specialSpellId;&#10;&#10;        var left = leftId == SpellId.None ? null : spellLibrary.Get(leftId);&#10;        var right = rightId == SpellId.None ? null : spellLibrary.Get(rightId);&#10;        var special = specialId == SpellId.None ? null : spellLibrary.Get(specialId);&#10;&#10;        // Validar tipos de slot&#10;        if (left &amp;&amp; left.slotType == SpellSlotType.SpecialOnly) left = null;&#10;        if (right &amp;&amp; right.slotType == SpellSlotType.SpecialOnly) right = null;&#10;        if (special &amp;&amp; special.slotType != SpellSlotType.SpecialOnly) special = null;&#10;&#10;        // Evitar duplicados en slots izq/der&#10;        if (left &amp;&amp; right &amp;&amp; leftId == rightId) right = null;&#10;&#10;        // Auto-completar slots vacíos (opcional)&#10;        if (autoFillEmptySlotsFromUnlocked &amp;&amp; preset.unlockedSpells != null)&#10;        {&#10;            MagicSpellSO FindFirstAvailable(bool requireSpecial, SpellId avoid)&#10;            {&#10;                foreach (var id in preset.unlockedSpells)&#10;                {&#10;                    if (id == SpellId.None || id == avoid) continue;&#10;                    var s = spellLibrary.Get(id);&#10;                    if (!s) continue;&#10;                    if (requireSpecial &amp;&amp; s.slotType != SpellSlotType.SpecialOnly) continue;&#10;                    if (!requireSpecial &amp;&amp; s.slotType == SpellSlotType.SpecialOnly) continue;&#10;                    return s;&#10;                }&#10;                return null;&#10;            }&#10;&#10;            if (!left) left = FindFirstAvailable(false, rightId);&#10;            if (!right) right = FindFirstAvailable(false, leftId);&#10;            if (!special) special = FindFirstAvailable(true, SpellId.None);&#10;        }&#10;&#10;        // Aplicar configuración al spawner&#10;        _spawner.SetSpells(left, right, special);&#10;        _spawner.SetInstigator(instigatorOverride ? instigatorOverride : gameObject);&#10;&#10;        Debug.Log($&quot;[PlayerPresetService] Hechizos configurados - L:{left?.name} R:{right?.name} S:{special?.name}&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;[DefaultExecutionOrder(-50)]&#10;[DisallowMultipleComponent]&#10;public class PlayerPresetService : MonoBehaviour&#10;{&#10;    [Header(&quot;Librería de hechizos (ID → SO)&quot;)]&#10;    [SerializeField] private SpellLibrarySO spellLibrary;&#10;&#10;    [Header(&quot;Opciones&quot;)]&#10;    [SerializeField] private bool autoFillEmptySlotsFromUnlocked; // default false por defecto&#10;    [SerializeField] private GameObject instigatorOverride;&#10;&#10;    MagicProjectileSpawner _spawner;&#10;    &#10;    // Evitar inicialización doble si el evento llega más de una vez o ya está listo al habilitar&#10;    bool _initialized;&#10;&#10;    void Awake()&#10;    {&#10;        _spawner = GetComponent&lt;MagicProjectileSpawner&gt;() ?? gameObject.AddComponent&lt;MagicProjectileSpawner&gt;();&#10;    }&#10;&#10;    // Suscribirnos al evento y cubrir el caso de que ya esté disponible&#10;    void OnEnable()&#10;    {&#10;        GameBootService.OnProfileReady += HandleProfileReady;&#10;        if (GameBootService.IsAvailable)&#10;        {&#10;            HandleProfileReady();&#10;        }&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;        GameBootService.OnProfileReady -= HandleProfileReady;&#10;    }&#10;&#10;    private void HandleProfileReady()&#10;    {&#10;        if (_initialized) return;&#10;        InitializePresetService();&#10;        _initialized = true;&#10;        // Ya no necesitamos el evento tras inicializar&#10;        GameBootService.OnProfileReady -= HandleProfileReady;&#10;    }&#10;&#10;    private void InitializePresetService()&#10;    {&#10;        var profile = GameBootService.Profile;&#10;        &#10;        if (!profile || !spellLibrary) &#10;        { &#10;            enabled = false; &#10;            Debug.LogError(&quot;[PlayerPresetService] Falta GameBootProfile o SpellLibrary.&quot;); &#10;            return; &#10;        }&#10;&#10;        var preset = profile.GetActivePresetResolved();&#10;        if (!preset) &#10;        { &#10;            Debug.LogWarning(&quot;[PlayerPresetService] Sin preset activo.&quot;); &#10;            return; &#10;        }&#10;&#10;        // Log inicial de diagnóstico&#10;        var entriesCount = spellLibrary.Entries != null ? spellLibrary.Entries.Count : -1;&#10;        int unlockedCount = preset.unlockedSpells != null ? preset.unlockedSpells.Count : 0;&#10;        Debug.Log($&quot;[PlayerPresetService] SpellLibrary entries: {entriesCount} | Unlocked: {unlockedCount} | Slots IDs → L:{preset.leftSpellId} R:{preset.rightSpellId} S:{preset.specialSpellId}&quot;);&#10;&#10;        // USAR EL ANCHOR DEL PRESET SO&#10;        if (!string.IsNullOrEmpty(preset.spawnAnchorId))&#10;        {&#10;            SpawnManager.SetCurrentAnchor(preset.spawnAnchorId);&#10;        }&#10;&#10;        // Configurar hechizos del preset&#10;        ConfigureSpells(preset);&#10;    }&#10;&#10;    private void ConfigureSpells(PlayerPresetSO preset)&#10;    {&#10;        // Resolver IDs respetando None&#10;        var leftId = preset.leftSpellId;&#10;        var rightId = preset.rightSpellId;&#10;        var specialId = preset.specialSpellId;&#10;&#10;        // Fallback: si no hay ningún slot asignado pero sí hay desbloqueados, autocompletamos aunque la opción esté desactivada&#10;        bool allNone = leftId == SpellId.None &amp;&amp; rightId == SpellId.None &amp;&amp; specialId == SpellId.None;&#10;        bool hasUnlocked = preset.unlockedSpells != null &amp;&amp; preset.unlockedSpells.Count &gt; 0;&#10;&#10;        var left = leftId == SpellId.None ? null : spellLibrary.Get(leftId);&#10;        var right = rightId == SpellId.None ? null : spellLibrary.Get(rightId);&#10;        var special = specialId == SpellId.None ? null : spellLibrary.Get(specialId);&#10;&#10;        if (leftId != SpellId.None &amp;&amp; left == null) Debug.LogWarning($&quot;[PlayerPresetService] Left ID {leftId} no está en SpellLibrary&quot;);&#10;        if (rightId != SpellId.None &amp;&amp; right == null) Debug.LogWarning($&quot;[PlayerPresetService] Right ID {rightId} no está en SpellLibrary&quot;);&#10;        if (specialId != SpellId.None &amp;&amp; special == null) Debug.LogWarning($&quot;[PlayerPresetService] Special ID {specialId} no está en SpellLibrary&quot;);&#10;&#10;        // Validar tipos de slot&#10;        if (left &amp;&amp; left.slotType == SpellSlotType.SpecialOnly) { Debug.LogWarning(&quot;[PlayerPresetService] Left es SpecialOnly, se descarta&quot;); left = null; }&#10;        if (right &amp;&amp; right.slotType == SpellSlotType.SpecialOnly) { Debug.LogWarning(&quot;[PlayerPresetService] Right es SpecialOnly, se descarta&quot;); right = null; }&#10;        if (special &amp;&amp; special.slotType != SpellSlotType.SpecialOnly) { Debug.LogWarning(&quot;[PlayerPresetService] Special no es SpecialOnly, se descarta&quot;); special = null; }&#10;&#10;        // Evitar duplicados en slots izq/der&#10;        if (left &amp;&amp; right &amp;&amp; leftId == rightId) { Debug.LogWarning(&quot;[PlayerPresetService] Left y Right tienen el mismo ID, se borra Right&quot;); right = null; }&#10;&#10;        // Auto-completar slots vacíos (opcional o por fallback si todos estaban None)&#10;        if ((autoFillEmptySlotsFromUnlocked || allNone) &amp;&amp; preset.unlockedSpells != null)&#10;        {&#10;            MagicSpellSO FindFirstAvailable(bool requireSpecial, SpellId avoid)&#10;            {&#10;                foreach (var id in preset.unlockedSpells)&#10;                {&#10;                    if (id == SpellId.None || id == avoid) continue;&#10;                    var s = spellLibrary.Get(id);&#10;                    if (!s) continue;&#10;                    if (requireSpecial &amp;&amp; s.slotType != SpellSlotType.SpecialOnly) continue;&#10;                    if (!requireSpecial &amp;&amp; s.slotType == SpellSlotType.SpecialOnly) continue;&#10;                    return s;&#10;                }&#10;                return null;&#10;            }&#10;&#10;            if (!left) left = FindFirstAvailable(false, rightId);&#10;            if (!right) right = FindFirstAvailable(false, leftId);&#10;            if (!special) special = FindFirstAvailable(true, SpellId.None);&#10;        }&#10;&#10;        // Aplicar configuración al spawner&#10;        _spawner.SetSpells(left, right, special);&#10;        _spawner.SetInstigator(instigatorOverride ? instigatorOverride : gameObject);&#10;&#10;        Debug.Log($&quot;[PlayerPresetService] Hechizos configurados - L:{left?.name} R:{right?.name} S:{special?.name}&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/World/PortalTrigger.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/World/PortalTrigger.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;[RequireComponent(typeof(Collider))]&#10;public class PortalTrigger : MonoBehaviour&#10;{&#10;    public string targetAnchorId;&#10;    public string requiredFlag;&#10;    public string setFlagOnEnter;&#10;&#10;    private bool _pendingUse;&#10;&#10;    void Reset(){ GetComponent&lt;Collider&gt;().isTrigger = true; }&#10;&#10;    void OnEnable()&#10;    {&#10;        GameBootService.OnProfileReady += HandleProfileReady;&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;        GameBootService.OnProfileReady -= HandleProfileReady;&#10;    }&#10;&#10;    private void HandleProfileReady()&#10;    {&#10;        if (_pendingUse)&#10;        {&#10;            var player = GameObject.FindWithTag(&quot;Player&quot;);&#10;            if (player != null)&#10;            {&#10;                ProcessPortal(player);&#10;            }&#10;            _pendingUse = false;&#10;        }&#10;    }&#10;&#10;    void OnTriggerEnter(Collider other)&#10;    {&#10;        if (!other.CompareTag(&quot;Player&quot;)) return;&#10;&#10;        if (GameBootService.IsAvailable)&#10;        {&#10;            ProcessPortal(other.gameObject);&#10;        }&#10;        else&#10;        {&#10;            // Diferir hasta que el GameBootProfile esté listo&#10;            _pendingUse = true;&#10;        }&#10;    }&#10;&#10;    private void ProcessPortal(GameObject player)&#10;    {&#10;        if (string.IsNullOrEmpty(targetAnchorId))&#10;        {&#10;            Debug.LogWarning(&quot;[PortalTrigger] targetAnchorId vacío&quot;);&#10;            return;&#10;        }&#10;&#10;        var bootProfile = GameBootService.Profile;&#10;        if (bootProfile == null)&#10;        {&#10;            Debug.LogError(&quot;[PortalTrigger] GameBootProfile no disponible en GameBootService&quot;);&#10;            return;&#10;        }&#10;&#10;        var preset = bootProfile.GetActivePresetResolved();&#10;        if (preset == null)&#10;        {&#10;            Debug.LogError(&quot;[PortalTrigger] No hay preset activo&quot;);&#10;            return;&#10;        }&#10;&#10;        // Verificar flag requerida&#10;        if (!string.IsNullOrEmpty(requiredFlag))&#10;        {&#10;            if (preset.flags == null || !preset.flags.Contains(requiredFlag))&#10;            {&#10;                Debug.Log($&quot;[PortalTrigger] Flag requerida '{requiredFlag}' no encontrada. Portal bloqueado.&quot;);&#10;                return;&#10;            }&#10;        }&#10;&#10;        // Establecer flag al entrar&#10;        if (!string.IsNullOrEmpty(setFlagOnEnter))&#10;        {&#10;            if (preset.flags == null)&#10;                preset.flags = new System.Collections.Generic.List&lt;string&gt;();&#10;            &#10;            if (!preset.flags.Contains(setFlagOnEnter))&#10;            {&#10;                preset.flags.Add(setFlagOnEnter);&#10;                Debug.Log($&quot;[PortalTrigger] Flag '{setFlagOnEnter}' establecida&quot;);&#10;            }&#10;        }&#10;&#10;        TeleportService.TeleportToAnchor(player, targetAnchorId);&#10;        // NO guardar aquí&#10;    }&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;[RequireComponent(typeof(Collider))]&#10;public class PortalTrigger : MonoBehaviour&#10;{&#10;    public string targetAnchorId;&#10;    public string requiredFlag;&#10;    public string setFlagOnEnter;&#10;&#10;    private bool _pendingUse;&#10;&#10;    void Reset(){ GetComponent&lt;Collider&gt;().isTrigger = true; }&#10;&#10;    void OnEnable()&#10;    {&#10;        GameBootService.OnProfileReady += HandleProfileReady;&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;        GameBootService.OnProfileReady -= HandleProfileReady;&#10;    }&#10;&#10;    private void HandleProfileReady()&#10;    {&#10;        if (_pendingUse)&#10;        {&#10;            var player = GameObject.FindWithTag(&quot;Player&quot;);&#10;            if (player != null)&#10;            {&#10;                ProcessPortal(player);&#10;            }&#10;            _pendingUse = false;&#10;        }&#10;    }&#10;&#10;    void OnTriggerEnter(Collider other)&#10;    {&#10;        if (!other.CompareTag(&quot;Player&quot;)) return;&#10;&#10;        if (GameBootService.IsAvailable)&#10;        {&#10;            ProcessPortal(other.gameObject);&#10;        }&#10;        else&#10;        {&#10;            // Diferir hasta que el GameBootProfile esté listo&#10;            _pendingUse = true;&#10;        }&#10;    }&#10;&#10;    private void ProcessPortal(GameObject player)&#10;    {&#10;        if (string.IsNullOrEmpty(targetAnchorId))&#10;        {&#10;            Debug.LogWarning(&quot;[PortalTrigger] targetAnchorId vacío&quot;);&#10;            return;&#10;        }&#10;&#10;        var bootProfile = GameBootService.Profile;&#10;        if (bootProfile == null)&#10;        {&#10;            Debug.LogError(&quot;[PortalTrigger] GameBootProfile no disponible en GameBootService&quot;);&#10;            return;&#10;        }&#10;&#10;        var preset = bootProfile.GetActivePresetResolved();&#10;        if (preset == null)&#10;        {&#10;            Debug.LogError(&quot;[PortalTrigger] No hay preset activo&quot;);&#10;            return;&#10;        }&#10;&#10;        // Verificar flag requerida&#10;        if (!string.IsNullOrEmpty(requiredFlag))&#10;        {&#10;            if (preset.flags == null || !preset.flags.Contains(requiredFlag))&#10;            {&#10;                Debug.Log($&quot;[PortalTrigger] Flag requerida '{requiredFlag}' no encontrada. Portal bloqueado.&quot;);&#10;                return;&#10;            }&#10;        }&#10;&#10;        // Establecer flag al entrar&#10;        if (!string.IsNullOrEmpty(setFlagOnEnter))&#10;        {&#10;            if (preset.flags == null)&#10;                preset.flags = new System.Collections.Generic.List&lt;string&gt;();&#10;            &#10;            if (!preset.flags.Contains(setFlagOnEnter))&#10;            {&#10;                preset.flags.Add(setFlagOnEnter);&#10;                Debug.Log($&quot;[PortalTrigger] Flag '{setFlagOnEnter}' establecida&quot;);&#10;            }&#10;        }&#10;&#10;        SpawnManager.TeleportTo(targetAnchorId, true);&#10;        // NO guardar aquí&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/World/SavePoint.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/World/SavePoint.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;[RequireComponent(typeof(Collider))]&#10;public class SavePoint : MonoBehaviour&#10;{&#10;    [Header(&quot;Config&quot;)]&#10;    public string anchorIdToSet;        // si lo dejas vacío, conserva el actual&#10;    public bool healOnSave = true;&#10;    public bool teleportAfterSave;&#10;    public string teleportAnchorId;&#10;&#10;    [Header(&quot;Interacción&quot;)]&#10;    public KeyCode interactKey = KeyCode.E;&#10;    public string prompt = &quot;Guardar partida (E)&quot;;&#10;&#10;    CanvasGroup _promptCg;&#10;&#10;    // Estado para diferir el guardado si el perfil no está listo&#10;    private bool _pendingSave;&#10;    private GameObject _pendingPlayer;&#10;&#10;    void Reset(){ GetComponent&lt;Collider&gt;().isTrigger = true; }&#10;&#10;    void OnEnable()&#10;    {&#10;        GameBootService.OnProfileReady += HandleProfileReady;&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;        GameBootService.OnProfileReady -= HandleProfileReady;&#10;    }&#10;&#10;    private void HandleProfileReady()&#10;    {&#10;        if (_pendingSave &amp;&amp; _pendingPlayer != null)&#10;        {&#10;            DoSave(_pendingPlayer);&#10;            _pendingSave = false;&#10;            _pendingPlayer = null;&#10;        }&#10;    }&#10;&#10;    void OnTriggerEnter(Collider other)&#10;    {&#10;        if (!other.CompareTag(&quot;Player&quot;)) return;&#10;        ShowPrompt(true);&#10;    }&#10;&#10;    void OnTriggerExit(Collider other)&#10;    {&#10;        if (!other.CompareTag(&quot;Player&quot;)) return;&#10;        ShowPrompt(false);&#10;    }&#10;&#10;    void OnTriggerStay(Collider other)&#10;    {&#10;        if (!other.CompareTag(&quot;Player&quot;)) return;&#10;        if (Input.GetKeyDown(interactKey))&#10;        {&#10;            if (GameBootService.IsAvailable)&#10;            {&#10;                DoSave(other.gameObject);&#10;            }&#10;            else&#10;            {&#10;                // Diferir hasta que el GameBootProfile esté listo&#10;                _pendingSave = true;&#10;                _pendingPlayer = other.gameObject;&#10;                Debug.Log(&quot;[SavePoint] Perfil no listo. Guardado diferido hasta OnProfileReady&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    void DoSave(GameObject playerGo)&#10;    {&#10;        var bootProfile = GameBootService.Profile;&#10;        if (bootProfile == null)&#10;        {&#10;            Debug.LogError(&quot;[SavePoint] GameBootProfile no disponible en GameBootService&quot;);&#10;            return;&#10;        }&#10;&#10;        if (!string.IsNullOrEmpty(anchorIdToSet))&#10;            SpawnManager.SetCurrentAnchor(anchorIdToSet);&#10;&#10;        if (healOnSave &amp;&amp; playerGo != null)&#10;        {&#10;            // Curar al jugador a través del PlayerHealthSystem&#10;            var playerHealth = playerGo.GetComponent&lt;PlayerHealthSystem&gt;() ?? playerGo.GetComponentInParent&lt;PlayerHealthSystem&gt;();&#10;            if (playerHealth != null)&#10;            {&#10;                playerHealth.SetCurrentHealth(playerHealth.MaxHealth);&#10;            }&#10;            &#10;            // Curar maná a través del ManaPool&#10;            var manaPool = playerGo.GetComponent&lt;ManaPool&gt;() ?? playerGo.GetComponentInParent&lt;ManaPool&gt;();&#10;            if (manaPool != null)&#10;            {&#10;                manaPool.Init(manaPool.Max, manaPool.Max);&#10;            }&#10;        }&#10;&#10;        // Guardar usando GameBootProfile&#10;        var saveSystem = FindFirstObjectByType&lt;SaveSystem&gt;();&#10;        if (saveSystem != null)&#10;        {&#10;            bool success = bootProfile.SaveCurrentGameState(saveSystem);&#10;            &#10;            if (success)&#10;            {&#10;                Debug.Log(&quot;[SavePoint] Partida guardada correctamente&quot;);&#10;                OnSaveCompleted?.Invoke();&#10;            }&#10;            else&#10;            {&#10;                Debug.LogError(&quot;[SavePoint] Error al guardar la partida&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.LogError(&quot;[SavePoint] No se encontró SaveSystem&quot;);&#10;        }&#10;&#10;        // Teletransporte opcional tras guardar&#10;        if (teleportAfterSave &amp;&amp; !string.IsNullOrEmpty(teleportAnchorId) &amp;&amp; playerGo != null)&#10;        {&#10;            TeleportService.TeleportToAnchor(playerGo, teleportAnchorId);&#10;        }&#10;    }&#10;&#10;    void ShowPrompt(bool show)&#10;    {&#10;        // opcional: si tienes un Canvas local con CanvasGroup para el prompt&#10;        if (!_promptCg) _promptCg = GetComponentInChildren&lt;CanvasGroup&gt;(true);&#10;        if (_promptCg){ _promptCg.alpha = show ? 1f : 0f; _promptCg.blocksRaycasts = show; }&#10;        // si no, pon aquí tu llamada a la UI global (TextMeshPro).&#10;        if (show) Debug.Log(prompt);&#10;    }&#10;&#10;    // Evento opcional para notificar cuando la partida se guarda correctamente&#10;    public event System.Action OnSaveCompleted;&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;[RequireComponent(typeof(Collider))]&#10;public class SavePoint : MonoBehaviour&#10;{&#10;    [Header(&quot;Config&quot;)]&#10;    public string anchorIdToSet;        // si lo dejas vacío, conserva el actual&#10;    public bool healOnSave = true;&#10;    public bool teleportAfterSave;&#10;    public string teleportAnchorId;&#10;&#10;    [Header(&quot;Interacción&quot;)]&#10;    public KeyCode interactKey = KeyCode.E;&#10;    public string prompt = &quot;Guardar partida (E)&quot;;&#10;&#10;    CanvasGroup _promptCg;&#10;&#10;    // Estado para diferir el guardado si el perfil no está listo&#10;    private bool _pendingSave;&#10;    private GameObject _pendingPlayer;&#10;&#10;    void Reset(){ GetComponent&lt;Collider&gt;().isTrigger = true; }&#10;&#10;    void OnEnable()&#10;    {&#10;        GameBootService.OnProfileReady += HandleProfileReady;&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;        GameBootService.OnProfileReady -= HandleProfileReady;&#10;    }&#10;&#10;    private void HandleProfileReady()&#10;    {&#10;        if (_pendingSave &amp;&amp; _pendingPlayer != null)&#10;        {&#10;            DoSave(_pendingPlayer);&#10;            _pendingSave = false;&#10;            _pendingPlayer = null;&#10;        }&#10;    }&#10;&#10;    void OnTriggerEnter(Collider other)&#10;    {&#10;        if (!other.CompareTag(&quot;Player&quot;)) return;&#10;        ShowPrompt(true);&#10;    }&#10;&#10;    void OnTriggerExit(Collider other)&#10;    {&#10;        if (!other.CompareTag(&quot;Player&quot;)) return;&#10;        ShowPrompt(false);&#10;    }&#10;&#10;    void OnTriggerStay(Collider other)&#10;    {&#10;        if (!other.CompareTag(&quot;Player&quot;)) return;&#10;        if (Input.GetKeyDown(interactKey))&#10;        {&#10;            if (GameBootService.IsAvailable)&#10;            {&#10;                DoSave(other.gameObject);&#10;            }&#10;            else&#10;            {&#10;                // Diferir hasta que el GameBootProfile esté listo&#10;                _pendingSave = true;&#10;                _pendingPlayer = other.gameObject;&#10;                Debug.Log(&quot;[SavePoint] Perfil no listo. Guardado diferido hasta OnProfileReady&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    void DoSave(GameObject playerGo)&#10;    {&#10;        var bootProfile = GameBootService.Profile;&#10;        if (bootProfile == null)&#10;        {&#10;            Debug.LogError(&quot;[SavePoint] GameBootProfile no disponible en GameBootService&quot;);&#10;            return;&#10;        }&#10;&#10;        if (!string.IsNullOrEmpty(anchorIdToSet))&#10;            SpawnManager.SetCurrentAnchor(anchorIdToSet);&#10;&#10;        if (healOnSave &amp;&amp; playerGo != null)&#10;        {&#10;            // Curar al jugador a través del PlayerHealthSystem&#10;            var playerHealth = playerGo.GetComponent&lt;PlayerHealthSystem&gt;() ?? playerGo.GetComponentInParent&lt;PlayerHealthSystem&gt;();&#10;            if (playerHealth != null)&#10;            {&#10;                playerHealth.SetCurrentHealth(playerHealth.MaxHealth);&#10;            }&#10;            &#10;            // Curar maná a través del ManaPool&#10;            var manaPool = playerGo.GetComponent&lt;ManaPool&gt;() ?? playerGo.GetComponentInParent&lt;ManaPool&gt;();&#10;            if (manaPool != null)&#10;            {&#10;                manaPool.Init(manaPool.Max, manaPool.Max);&#10;            }&#10;        }&#10;&#10;        // Guardar usando GameBootProfile&#10;        var saveSystem = FindFirstObjectByType&lt;SaveSystem&gt;();&#10;        if (saveSystem != null)&#10;        {&#10;            bool success = bootProfile.SaveCurrentGameState(saveSystem);&#10;            &#10;            if (success)&#10;            {&#10;                Debug.Log(&quot;[SavePoint] Partida guardada correctamente&quot;);&#10;                OnSaveCompleted?.Invoke();&#10;            }&#10;            else&#10;            {&#10;                Debug.LogError(&quot;[SavePoint] Error al guardar la partida&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.LogError(&quot;[SavePoint] No se encontró SaveSystem&quot;);&#10;        }&#10;&#10;        // Teletransporte opcional tras guardar&#10;        if (teleportAfterSave &amp;&amp; !string.IsNullOrEmpty(teleportAnchorId) &amp;&amp; playerGo != null)&#10;        {&#10;            SpawnManager.TeleportTo(teleportAnchorId, true);&#10;        }&#10;    }&#10;&#10;    void ShowPrompt(bool show)&#10;    {&#10;        // opcional: si tienes un Canvas local con CanvasGroup para el prompt&#10;        if (!_promptCg) _promptCg = GetComponentInChildren&lt;CanvasGroup&gt;(true);&#10;        if (_promptCg){ _promptCg.alpha = show ? 1f : 0f; _promptCg.blocksRaycasts = show; }&#10;        // si no, pon aquí tu llamada a la UI global (TextMeshPro).&#10;        if (show) Debug.Log(prompt);&#10;    }&#10;&#10;    // Evento opcional para notificar cuando la partida se guarda correctamente&#10;    public event System.Action OnSaveCompleted;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/World/SpawnManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/World/SpawnManager.cs" />
              <option name="originalContent" value="using System;&#10;using UnityEngine;&#10;&#10;public class SpawnManager : MonoBehaviour&#10;{&#10;    // Estado global del anchor actual&#10;    public static string CurrentAnchorId { get; private set; }&#10;&#10;    // Evento opcional para quien quiera reaccionar a cambios de anchor (HUD, etc.)&#10;    public static event Action&lt;string&gt; OnAnchorChanged;&#10;&#10;    private bool _initialized;&#10;&#10;    void OnEnable()&#10;    {&#10;        GameBootService.OnProfileReady += HandleProfileReady;&#10;        if (GameBootService.IsAvailable)&#10;        {&#10;            HandleProfileReady();&#10;        }&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;        GameBootService.OnProfileReady -= HandleProfileReady;&#10;    }&#10;&#10;    private void HandleProfileReady()&#10;    {&#10;        if (_initialized) return;&#10;&#10;        // Inicializar con el anchor del preset activo&#10;        var bootProfile = GameBootService.Profile;&#10;        if (bootProfile != null)&#10;        {&#10;            var startAnchor = bootProfile.GetStartAnchorOrDefault();&#10;            if (!string.IsNullOrEmpty(startAnchor))&#10;            {&#10;                SetCurrentAnchor(startAnchor);&#10;            }&#10;        }&#10;&#10;        _initialized = true;&#10;        GameBootService.OnProfileReady -= HandleProfileReady;&#10;    }&#10;&#10;    /// &lt;summary&gt;Establece el anchor actual (no mueve al jugador).&lt;/summary&gt;&#10;    public static void SetCurrentAnchor(string id)&#10;    {&#10;        if (string.IsNullOrEmpty(id)) return;&#10;        if (id == CurrentAnchorId) return;&#10;&#10;        CurrentAnchorId = id;&#10;&#10;        // Persistir también en el runtimePreset del GameBootProfile&#10;        var profile = GameBootService.Profile;&#10;        if (profile != null)&#10;        {&#10;            var preset = profile.GetActivePresetResolved();&#10;            if (preset != null)&#10;            {&#10;                preset.spawnAnchorId = id;&#10;            }&#10;        }&#10;&#10;        OnAnchorChanged?.Invoke(id);&#10;        // Debug.Log($&quot;[SpawnManager] CurrentAnchorId = {id}&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;Devuelve el SpawnAnchor por id usando tu clase del mundo.&lt;/summary&gt;&#10;    public static SpawnAnchor GetAnchor(string anchorId)&#10;    {&#10;        return SpawnAnchor.FindById(anchorId);&#10;    }&#10;&#10;    /// &lt;summary&gt;Coloca al jugador en el anchor indicado usando TeleportService.&lt;/summary&gt;&#10;    public static void PlaceAtAnchor(GameObject player, string anchorId, bool immediate = true)&#10;    {&#10;        TeleportService.PlaceAtAnchor(player, anchorId, immediate);&#10;        // TeleportService ya llama a SetCurrentAnchor(anchorId)&#10;    }&#10;&#10;    /// &lt;summary&gt;Coloca al jugador en el anchor actual (si existe).&lt;/summary&gt;&#10;    public static void PlaceAtCurrent(GameObject player, bool immediate = true)&#10;    {&#10;        if (string.IsNullOrEmpty(CurrentAnchorId)) return;&#10;        TeleportService.PlaceAtAnchor(player, CurrentAnchorId, immediate);&#10;    }&#10;&#10;    /// &lt;summary&gt;Teletransporta al jugador al anchor indicado por id.&lt;/summary&gt;&#10;    public static void TeleportTo(string anchorId, bool? useTransition = null)&#10;    {&#10;        if (string.IsNullOrEmpty(anchorId)) return;&#10;        var player = GameObject.FindWithTag(&quot;Player&quot;);&#10;        if (!player) { Debug.LogWarning(&quot;[SpawnManager] No se encontró player para teletransporte&quot;); return; }&#10;        TeleportService.TeleportToAnchor(player, anchorId, useTransition);&#10;    }&#10;&#10;    /// &lt;summary&gt;Teletransporta al jugador al anchor actual.&lt;/summary&gt;&#10;    public static void TeleportToCurrent(bool? useTransition = null)&#10;    {&#10;        if (string.IsNullOrEmpty(CurrentAnchorId)) return;&#10;        var player = GameObject.FindWithTag(&quot;Player&quot;);&#10;        if (!player) { Debug.LogWarning(&quot;[SpawnManager] No se encontró player para teletransporte&quot;); return; }&#10;        TeleportService.TeleportToAnchor(player, CurrentAnchorId, useTransition);&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;&#10;public class SpawnManager : MonoBehaviour&#10;{&#10;    // Estado global del anchor actual&#10;    public static string CurrentAnchorId { get; private set; }&#10;&#10;    // Evento opcional para quien quiera reaccionar a cambios de anchor (HUD, etc.)&#10;    public static event Action&lt;string&gt; OnAnchorChanged;&#10;&#10;    private bool _initialized;&#10;&#10;    void OnEnable()&#10;    {&#10;        GameBootService.OnProfileReady += HandleProfileReady;&#10;        if (GameBootService.IsAvailable)&#10;        {&#10;            HandleProfileReady();&#10;        }&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;        GameBootService.OnProfileReady -= HandleProfileReady;&#10;    }&#10;&#10;    private void HandleProfileReady()&#10;    {&#10;        if (_initialized) return;&#10;&#10;        // Inicializar con el anchor del preset activo&#10;        var bootProfile = GameBootService.Profile;&#10;        if (bootProfile != null)&#10;        {&#10;            var startAnchor = bootProfile.GetStartAnchorOrDefault();&#10;            if (!string.IsNullOrEmpty(startAnchor))&#10;            {&#10;                SetCurrentAnchor(startAnchor);&#10;            }&#10;        }&#10;&#10;        _initialized = true;&#10;        GameBootService.OnProfileReady -= HandleProfileReady;&#10;    }&#10;&#10;    /// &lt;summary&gt;Establece el anchor actual (no mueve al jugador).&lt;/summary&gt;&#10;    public static void SetCurrentAnchor(string id)&#10;    {&#10;        if (string.IsNullOrEmpty(id)) return;&#10;        if (id == CurrentAnchorId) return;&#10;&#10;        CurrentAnchorId = id;&#10;&#10;        // Persistir también en el runtimePreset del GameBootProfile&#10;        var profile = GameBootService.Profile;&#10;        if (profile != null)&#10;        {&#10;            var preset = profile.GetActivePresetResolved();&#10;            if (preset != null)&#10;            {&#10;                preset.spawnAnchorId = id;&#10;            }&#10;        }&#10;&#10;        OnAnchorChanged?.Invoke(id);&#10;        // Debug.Log($&quot;[SpawnManager] CurrentAnchorId = {id}&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;Devuelve el SpawnAnchor por id usando tu clase del mundo.&lt;/summary&gt;&#10;    public static SpawnAnchor GetAnchor(string anchorId)&#10;    {&#10;        return SpawnAnchor.FindById(anchorId);&#10;    }&#10;&#10;    /// &lt;summary&gt;Teletransporta al jugador al anchor indicado por id.&lt;/summary&gt;&#10;    public static void TeleportTo(string anchorId, bool? useTransition = null)&#10;    {&#10;        if (string.IsNullOrEmpty(anchorId)) return;&#10;        var player = GameObject.FindWithTag(&quot;Player&quot;);&#10;        if (!player) { Debug.LogWarning(&quot;[SpawnManager] No se encontró player para teletransporte&quot;); return; }&#10;        TeleportService.TeleportToAnchor(player, anchorId, useTransition);&#10;    }&#10;&#10;    /// &lt;summary&gt;Teletransporta al jugador al anchor actual.&lt;/summary&gt;&#10;    public static void TeleportToCurrent(bool? useTransition = null)&#10;    {&#10;        if (string.IsNullOrEmpty(CurrentAnchorId)) return;&#10;        var player = GameObject.FindWithTag(&quot;Player&quot;);&#10;        if (!player) { Debug.LogWarning(&quot;[SpawnManager] No se encontró player para teletransporte&quot;); return; }&#10;        TeleportService.TeleportToAnchor(player, CurrentAnchorId, useTransition);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/World/WorldBootstrap.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/World/WorldBootstrap.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;public class WorldBootstrap : MonoBehaviour&#10;{&#10;    private SaveSystem _saveSystem;&#10;    private bool _initialized;&#10;&#10;    void OnEnable()&#10;    {&#10;        GameBootService.OnProfileReady += HandleProfileReady;&#10;        if (GameBootService.IsAvailable)&#10;        {&#10;            HandleProfileReady();&#10;        }&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;        GameBootService.OnProfileReady -= HandleProfileReady;&#10;    }&#10;&#10;    private void HandleProfileReady()&#10;    {&#10;        if (_initialized) return;&#10;        InitializeWorld();&#10;        _initialized = true;&#10;        GameBootService.OnProfileReady -= HandleProfileReady;&#10;    }&#10;&#10;    private void InitializeWorld()&#10;    {&#10;        var bootProfile = GameBootService.Profile;&#10;        if (bootProfile == null)&#10;        {&#10;            Debug.LogError(&quot;[WorldBootstrap] ¡No se encontró GameBootProfile en GameBootService!&quot;);&#10;            return;&#10;        }&#10;&#10;        _saveSystem = FindFirstObjectByType&lt;SaveSystem&gt;();&#10;&#10;        // 1) Modo PRESET (test): ignora el save&#10;        if (bootProfile.ShouldBootFromPreset())&#10;        {&#10;            var anchor = bootProfile.GetStartAnchorOrDefault();&#10;            SpawnManager.SetCurrentAnchor(anchor);&#10;&#10;            var playerGo = GameObject.FindWithTag(&quot;Player&quot;);&#10;            if (playerGo) TeleportService.PlaceAtAnchor(playerGo, anchor, immediate: true);&#10;&#10;            Debug.Log(&quot;[WorldBootstrap] Iniciado en modo PRESET&quot;);&#10;            return;&#10;        }&#10;&#10;        // 2) Flujo normal: intentar cargar partida; si no, usar anchor del preset activo&#10;        string anchorId = bootProfile.GetStartAnchorOrDefault();&#10;&#10;        if (_saveSystem != null &amp;&amp; _saveSystem.Load(out var data))&#10;        {&#10;            if (!string.IsNullOrEmpty(data.lastSpawnAnchorId))&#10;                anchorId = data.lastSpawnAnchorId;&#10;&#10;            // Actualizar runtimePreset con los datos del save&#10;            var slotTemplate = bootProfile.bootPreset ? bootProfile.bootPreset : bootProfile.defaultPlayerPreset;&#10;            bootProfile.SetRuntimePresetFromSave(data, slotTemplate);&#10;&#10;            Debug.Log(&quot;[WorldBootstrap] Save cargado correctamente&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.Log(&quot;[WorldBootstrap] Sin save disponible, usando configuración por defecto&quot;);&#10;        }&#10;&#10;        // 3) Colocar jugador&#10;        SpawnManager.SetCurrentAnchor(anchorId);&#10;        var player = GameObject.FindWithTag(&quot;Player&quot;);&#10;        if (player) &#10;        {&#10;            TeleportService.PlaceAtAnchor(player, anchorId, immediate: true);&#10;            Debug.Log($&quot;[WorldBootstrap] Jugador colocado en anchor: {anchorId}&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[WorldBootstrap] No se encontró el jugador con tag 'Player'&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;public class WorldBootstrap : MonoBehaviour&#10;{&#10;    private SaveSystem _saveSystem;&#10;    private bool _initialized;&#10;&#10;    void OnEnable()&#10;    {&#10;        GameBootService.OnProfileReady += HandleProfileReady;&#10;        if (GameBootService.IsAvailable)&#10;        {&#10;            HandleProfileReady();&#10;        }&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;        GameBootService.OnProfileReady -= HandleProfileReady;&#10;    }&#10;&#10;    private void HandleProfileReady()&#10;    {&#10;        if (_initialized) return;&#10;        InitializeWorld();&#10;        _initialized = true;&#10;        GameBootService.OnProfileReady -= HandleProfileReady;&#10;    }&#10;&#10;    private void InitializeWorld()&#10;    {&#10;        var bootProfile = GameBootService.Profile;&#10;        if (bootProfile == null)&#10;        {&#10;            Debug.LogError(&quot;[WorldBootstrap] ¡No se encontró GameBootProfile en GameBootService!&quot;);&#10;            return;&#10;        }&#10;&#10;        _saveSystem = FindFirstObjectByType&lt;SaveSystem&gt;();&#10;&#10;        // 1) Modo PRESET (test): ignora el save&#10;        if (bootProfile.ShouldBootFromPreset())&#10;        {&#10;            var anchor = bootProfile.GetStartAnchorOrDefault();&#10;            SpawnManager.SetCurrentAnchor(anchor);&#10;&#10;            var playerGo = GameObject.FindWithTag(&quot;Player&quot;);&#10;            if (playerGo) SpawnManager.TeleportTo(anchor, true);&#10;&#10;            Debug.Log(&quot;[WorldBootstrap] Iniciado en modo PRESET&quot;);&#10;            return;&#10;        }&#10;&#10;        // 2) Flujo normal: intentar cargar partida; si no, usar anchor del preset activo&#10;        string anchorId = bootProfile.GetStartAnchorOrDefault();&#10;&#10;        if (_saveSystem != null &amp;&amp; _saveSystem.Load(out var data))&#10;        {&#10;            if (!string.IsNullOrEmpty(data.lastSpawnAnchorId))&#10;                anchorId = data.lastSpawnAnchorId;&#10;&#10;            // Actualizar runtimePreset con los datos del save&#10;            var slotTemplate = bootProfile.bootPreset ? bootProfile.bootPreset : bootProfile.defaultPlayerPreset;&#10;            bootProfile.SetRuntimePresetFromSave(data, slotTemplate);&#10;&#10;            Debug.Log(&quot;[WorldBootstrap] Save cargado correctamente&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.Log(&quot;[WorldBootstrap] Sin save disponible, usando configuración por defecto&quot;);&#10;        }&#10;&#10;        // 3) Colocar jugador&#10;        SpawnManager.SetCurrentAnchor(anchorId);&#10;        var player = GameObject.FindWithTag(&quot;Player&quot;);&#10;        if (player) &#10;        {&#10;            SpawnManager.TeleportTo(anchorId, true);&#10;            Debug.Log($&quot;[WorldBootstrap] Jugador colocado en anchor: {anchorId}&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[WorldBootstrap] No se encontró el jugador con tag 'Player'&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>