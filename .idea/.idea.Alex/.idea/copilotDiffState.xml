<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Quests/QuestLogItemUI.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Quests/QuestLogItemUI.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using TMPro;&#10;using System;&#10;using UnityEngine.EventSystems;&#10;&#10;public class QuestLogItemUI : MonoBehaviour, IPointerClickHandler&#10;{&#10;    [Header(&quot;UI&quot;)]&#10;    [SerializeField] private TextMeshProUGUI questName;&#10;    [SerializeField] private TextMeshProUGUI statePillText;&#10;    [SerializeField] private Image statePillBg;&#10;    [SerializeField] private TextMeshProUGUI progressText;&#10;    [SerializeField] private Image progressFill;      // barra de progreso (Fill)&#10;    [SerializeField] private Transform stepsRoot;     // contenedor de steps&#10;    [SerializeField] private QuestStepItemUI stepPrefab;&#10;    [SerializeField] private GameObject stepsContainer; // el GameObject completo para show/hide&#10;&#10;    [Header(&quot;Estilos&quot;)]&#10;    [SerializeField] private Color colorInactive = new Color(0.6f,0.6f,0.6f);&#10;    [SerializeField] private Color colorActive = new Color(0.2f,0.6f,1f);&#10;    [SerializeField] private Color colorCompleted = new Color(0.3f,0.8f,0.4f);&#10;&#10;    private bool _isExpanded = false;&#10;&#10;    public void Bind(QuestManager.RuntimeQuest data)&#10;    {&#10;        string display = string.IsNullOrEmpty(data.Data.displayName) ? data.Id : data.Data.displayName;&#10;        if (questName) questName.text = display;&#10;&#10;        switch (data.State)&#10;        {&#10;            case QuestState.Inactive:&#10;                if (statePillText) statePillText.text = &quot;Inactiva&quot;;&#10;                if (statePillBg) statePillBg.color = colorInactive;&#10;                break;&#10;            case QuestState.Active:&#10;                if (statePillText) statePillText.text = &quot;Activa&quot;;&#10;                if (statePillBg) statePillBg.color = colorActive;&#10;                break;&#10;            case QuestState.Completed:&#10;                if (statePillText) statePillText.text = &quot;Completada&quot;;&#10;                if (statePillBg) statePillBg.color = colorCompleted;&#10;                break;&#10;        }&#10;&#10;        var steps = data.Steps ?? Array.Empty&lt;QuestStep&gt;();&#10;        int done = 0;&#10;        foreach (var s in steps) if (s.completed) done++;&#10;        float pct = (steps.Length == 0) ? 1f : (float)done / steps.Length;&#10;&#10;        if (progressFill) progressFill.fillAmount = pct;&#10;        if (progressText) progressText.text = steps.Length &gt; 0 ? $&quot;{done}/{steps.Length}&quot; : &quot;—&quot;;&#10;&#10;        if (stepsRoot &amp;&amp; stepPrefab)&#10;        {&#10;            for (int i = stepsRoot.childCount - 1; i &gt;= 0; i--)&#10;                GameObject.Destroy(stepsRoot.GetChild(i).gameObject);&#10;&#10;            for (int i = 0; i &lt; steps.Length; i++)&#10;            {&#10;                var item = GameObject.Instantiate(stepPrefab, stepsRoot);&#10;                item.Bind(steps[i]);&#10;            }&#10;        }&#10;&#10;        // Inicialmente colapsado&#10;        SetExpanded(false);&#10;    }&#10;&#10;    public void OnPointerClick(PointerEventData eventData)&#10;    {&#10;        ToggleExpanded();&#10;    }&#10;&#10;    public void ToggleExpanded()&#10;    {&#10;        SetExpanded(!_isExpanded);&#10;    }&#10;&#10;    public void SetExpanded(bool expanded)&#10;    {&#10;        _isExpanded = expanded;&#10;        if (stepsContainer)&#10;        {&#10;            stepsContainer.SetActive(_isExpanded);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using TMPro;&#10;using System;&#10;using UnityEngine.EventSystems;&#10;&#10;public class QuestLogItemUI : MonoBehaviour, IPointerClickHandler&#10;{&#10;    [Header(&quot;UI&quot;)]&#10;    [SerializeField] private TextMeshProUGUI questName;&#10;    [SerializeField] private TextMeshProUGUI firstStepDesc; // Descripción del primer paso activo&#10;    [SerializeField] private TextMeshProUGUI statePillText;&#10;    [SerializeField] private Image statePillBg;&#10;    [SerializeField] private TextMeshProUGUI progressText;&#10;    [SerializeField] private Image progressFill;      // barra de progreso (Fill)&#10;    [SerializeField] private Transform stepsRoot;     // contenedor de steps&#10;    [SerializeField] private QuestStepItemUI stepPrefab;&#10;    [SerializeField] private GameObject stepsContainer; // el GameObject completo para show/hide&#10;&#10;    [Header(&quot;Estilos&quot;)]&#10;    [SerializeField] private Color colorInactive = new Color(0.6f,0.6f,0.6f);&#10;    [SerializeField] private Color colorActive = new Color(0.2f,0.6f,1f);&#10;    [SerializeField] private Color colorCompleted = new Color(0.3f,0.8f,0.4f);&#10;&#10;    private bool _isExpanded = false;&#10;&#10;    public void Bind(QuestManager.RuntimeQuest data)&#10;    {&#10;        // Título de la quest&#10;        string display = string.IsNullOrEmpty(data.Data.displayName) ? data.Id : data.Data.displayName;&#10;        if (questName) questName.text = display;&#10;&#10;        // Obtener steps una sola vez para todo el método&#10;        var steps = data.Steps ?? Array.Empty&lt;QuestStep&gt;();&#10;&#10;        // Descripción del primer paso no completado&#10;        if (firstStepDesc)&#10;        {&#10;            string stepDescription = &quot;&quot;;&#10;            &#10;            // Buscar el primer paso no completado&#10;            foreach (var step in steps)&#10;            {&#10;                if (!step.completed)&#10;                {&#10;                    stepDescription = step.description;&#10;                    break;&#10;                }&#10;            }&#10;            &#10;            // Si todos están completados, mostrar el último paso&#10;            if (string.IsNullOrEmpty(stepDescription) &amp;&amp; steps.Length &gt; 0)&#10;            {&#10;                stepDescription = steps[steps.Length - 1].description;&#10;            }&#10;            &#10;            firstStepDesc.text = stepDescription;&#10;        }&#10;&#10;        switch (data.State)&#10;        {&#10;            case QuestState.Inactive:&#10;                if (statePillText) statePillText.text = &quot;Inactiva&quot;;&#10;                if (statePillBg) statePillBg.color = colorInactive;&#10;                break;&#10;            case QuestState.Active:&#10;                if (statePillText) statePillText.text = &quot;Activa&quot;;&#10;                if (statePillBg) statePillBg.color = colorActive;&#10;                break;&#10;            case QuestState.Completed:&#10;                if (statePillText) statePillText.text = &quot;Completada&quot;;&#10;                if (statePillBg) statePillBg.color = colorCompleted;&#10;                break;&#10;        }&#10;&#10;        // Calcular progreso&#10;        int done = 0;&#10;        foreach (var s in steps) if (s.completed) done++;&#10;        float pct = (steps.Length == 0) ? 1f : (float)done / steps.Length;&#10;&#10;        if (progressFill) progressFill.fillAmount = pct;&#10;        if (progressText) progressText.text = steps.Length &gt; 0 ? $&quot;{done}/{steps.Length}&quot; : &quot;—&quot;;&#10;&#10;        if (stepsRoot &amp;&amp; stepPrefab)&#10;        {&#10;            for (int i = stepsRoot.childCount - 1; i &gt;= 0; i--)&#10;                GameObject.Destroy(stepsRoot.GetChild(i).gameObject);&#10;&#10;            for (int i = 0; i &lt; steps.Length; i++)&#10;            {&#10;                var item = GameObject.Instantiate(stepPrefab, stepsRoot);&#10;                item.Bind(steps[i]);&#10;            }&#10;        }&#10;&#10;        // Inicialmente colapsado&#10;        SetExpanded(false);&#10;    }&#10;&#10;    public void OnPointerClick(PointerEventData eventData)&#10;    {&#10;        ToggleExpanded();&#10;    }&#10;&#10;    public void ToggleExpanded()&#10;    {&#10;        SetExpanded(!_isExpanded);&#10;    }&#10;&#10;    public void SetExpanded(bool expanded)&#10;    {&#10;        _isExpanded = expanded;&#10;        if (stepsContainer)&#10;        {&#10;            stepsContainer.SetActive(_isExpanded);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Quests/QuestLogListUI.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Quests/QuestLogListUI.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using TMPro;&#10;using System.Collections;&#10;&#10;public class QuestLogListUI : MonoBehaviour&#10;{&#10;    [Header(&quot;Refs&quot;)]&#10;    [SerializeField] private Transform contentRoot;      // ScrollView/Viewport/Content&#10;    [SerializeField] private QuestLogItemUI itemPrefab;  // Prefab de item misión&#10;    [SerializeField] private TextMeshProUGUI headerText; // &quot;Misiones&quot; (opcional)&#10;    [SerializeField] private bool showInactive = false;  // filtrar inactivas&#10;    [SerializeField] private GameObject panelRoot;       // El panel completo para show/hide&#10;    [SerializeField] private GameObject scrollView;      // Solo el ScrollView para ocultar&#10;    [SerializeField] private TextMeshProUGUI helpText;   // Texto de ayuda para cambiar&#10;&#10;    bool _bound;                    // ya suscrito al manager&#10;    QuestManager _qm;               // cache del manager suscrito&#10;    Coroutine _waitCo;&#10;    private bool _isPanelVisible = true; // Estado del panel&#10;&#10;    void OnEnable()&#10;    {&#10;        // Empieza a esperar al manager si aún no existe&#10;        _waitCo = StartCoroutine(BindWhenReady());&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;        Unbind();&#10;        if (_waitCo != null) { StopCoroutine(_waitCo); _waitCo = null; }&#10;    }&#10;&#10;    void Update()&#10;    {&#10;        // Control con D-pad arriba&#10;        // Opción 1: Sistema antiguo Input Manager (requiere configurar &quot;DPadUp&quot; en Input Manager)&#10;        bool dpadUpPressed = false;&#10;        &#10;        #if ENABLE_INPUT_SYSTEM&#10;        // Nuevo Input System&#10;        if (UnityEngine.InputSystem.Gamepad.current != null)&#10;        {&#10;            dpadUpPressed = UnityEngine.InputSystem.Gamepad.current.dpad.up.wasPressedThisFrame;&#10;        }&#10;        #endif&#10;        &#10;        // Sistema antiguo - prueba varias opciones comunes para D-pad Up&#10;        if (!dpadUpPressed)&#10;        {&#10;            // Intenta con el botón configurado&#10;            try { dpadUpPressed = Input.GetButtonDown(&quot;DPadUp&quot;); } catch { }&#10;            &#10;            // Alternativas comunes para D-pad Up en diferentes mandos&#10;            if (!dpadUpPressed) dpadUpPressed = Input.GetKeyDown(KeyCode.UpArrow); // Flecha arriba del teclado&#10;            if (!dpadUpPressed) dpadUpPressed = Input.GetKeyDown(KeyCode.U); // Tecla U como fallback&#10;            if (!dpadUpPressed) dpadUpPressed = Input.GetKeyDown(KeyCode.JoystickButton4); // Algunos mandos&#10;            &#10;            // Axis 7 para D-pad vertical (valor &gt; 0.5 = arriba)&#10;            if (!dpadUpPressed &amp;&amp; Input.GetAxis(&quot;Vertical&quot;) &gt; 0.5f &amp;&amp; !_lastFrameDpadUp)&#10;            {&#10;                dpadUpPressed = true;&#10;            }&#10;        }&#10;        &#10;        if (dpadUpPressed)&#10;        {&#10;            TogglePanel();&#10;        }&#10;        &#10;        _lastFrameDpadUp = Input.GetAxis(&quot;Vertical&quot;) &gt; 0.5f;&#10;    }&#10;&#10;    private bool _lastFrameDpadUp = false;&#10;&#10;    IEnumerator BindWhenReady()&#10;    {&#10;        // Espera a que QuestManager exista (creado por tu escena Start)&#10;        while (QuestManager.Instance == null) yield return null;&#10;&#10;        // Si cambió de instancia (p.ej. reload), re-suscribe limpio&#10;        if (_qm != QuestManager.Instance)&#10;        {&#10;            Unbind();&#10;            _qm = QuestManager.Instance;&#10;            _qm.OnQuestsChanged += Rebuild;&#10;            _bound = true;&#10;        }&#10;&#10;        Rebuild();&#10;    }&#10;&#10;    void Unbind()&#10;    {&#10;        if (_bound &amp;&amp; _qm != null)&#10;        {&#10;            _qm.OnQuestsChanged -= Rebuild;&#10;        }&#10;        _bound = false;&#10;        _qm = null;&#10;    }&#10;&#10;    public void Rebuild()&#10;    {&#10;        if (!contentRoot || itemPrefab == null) return;&#10;        if (QuestManager.Instance == null) return; // por si se descargó la escena&#10;&#10;        // limpiar&#10;        for (int i = contentRoot.childCount - 1; i &gt;= 0; i--)&#10;            Destroy(contentRoot.GetChild(i).gameObject);&#10;&#10;        // poblar&#10;        foreach (var rq in QuestManager.Instance.GetAll())&#10;        {&#10;            if (!showInactive &amp;&amp; rq.State == QuestState.Inactive) continue;&#10;            var go = Instantiate(itemPrefab, contentRoot);&#10;            go.Bind(rq); // el propio item gestiona nulls internos&#10;        }&#10;&#10;        if (headerText) headerText.text = &quot;Misiones&quot;;&#10;    }&#10;&#10;    public void TogglePanel()&#10;    {&#10;        _isPanelVisible = !_isPanelVisible;&#10;        &#10;        // Solo ocultar el ScrollView, no todo el panel&#10;        if (scrollView)&#10;        {&#10;            scrollView.SetActive(_isPanelVisible);&#10;        }&#10;        &#10;        // Actualizar el texto de ayuda según el estado&#10;        if (helpText)&#10;        {&#10;            if (_isPanelVisible)&#10;            {&#10;                helpText.text = &quot;[D-Pad ▲] Ocultar&quot;;&#10;            }&#10;            else&#10;            {&#10;                helpText.text = &quot;[D-Pad ▲] Mostrar&quot;;&#10;            }&#10;        }&#10;    }&#10;&#10;    public void ShowPanel(bool show)&#10;    {&#10;        _isPanelVisible = show;&#10;        &#10;        if (scrollView)&#10;        {&#10;            scrollView.SetActive(_isPanelVisible);&#10;        }&#10;        &#10;        if (helpText)&#10;        {&#10;            if (_isPanelVisible)&#10;            {&#10;                helpText.text = &quot;[D-Pad ▲] Ocultar&quot;;&#10;            }&#10;            else&#10;            {&#10;                helpText.text = &quot;[D-Pad ▲] Mostrar&quot;;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using TMPro;&#10;using System.Collections;&#10;&#10;public class QuestLogListUI : MonoBehaviour&#10;{&#10;    [Header(&quot;Refs&quot;)]&#10;    [SerializeField] private Transform contentRoot;      // ScrollView/Viewport/Content&#10;    [SerializeField] private QuestLogItemUI itemPrefab;  // Prefab de item misión&#10;    [SerializeField] private TextMeshProUGUI headerText; // &quot;Misiones&quot; (opcional)&#10;    [SerializeField] private bool showInactive = false;  // filtrar inactivas&#10;    [SerializeField] private GameObject panelRoot;       // El panel completo para show/hide&#10;    [SerializeField] private GameObject scrollView;      // Solo el ScrollView para ocultar&#10;    [SerializeField] private TextMeshProUGUI helpText;   // Texto de ayuda para cambiar&#10;&#10;    bool _bound;                    // ya suscrito al manager&#10;    QuestManager _qm;               // cache del manager suscrito&#10;    Coroutine _waitCo;&#10;    private bool _isPanelVisible = true; // Estado del panel&#10;&#10;    void OnEnable()&#10;    {&#10;        // Empieza a esperar al manager si aún no existe&#10;        _waitCo = StartCoroutine(BindWhenReady());&#10;    }&#10;&#10;    void OnDisable()&#10;    {&#10;        Unbind();&#10;        if (_waitCo != null) { StopCoroutine(_waitCo); _waitCo = null; }&#10;    }&#10;&#10;    void Update()&#10;    {&#10;        // Control con D-pad arriba SOLAMENTE (no joystick izquierdo)&#10;        bool dpadUpPressed = false;&#10;        &#10;        #if ENABLE_INPUT_SYSTEM&#10;        // Nuevo Input System&#10;        if (UnityEngine.InputSystem.Gamepad.current != null)&#10;        {&#10;            dpadUpPressed = UnityEngine.InputSystem.Gamepad.current.dpad.up.wasPressedThisFrame;&#10;        }&#10;        #endif&#10;        &#10;        // Sistema antiguo - prueba varias opciones comunes para D-pad Up&#10;        if (!dpadUpPressed)&#10;        {&#10;            // Intenta con el botón configurado&#10;            try { dpadUpPressed = Input.GetButtonDown(&quot;DPadUp&quot;); } catch { }&#10;            &#10;            // Alternativas comunes para D-pad Up en diferentes mandos&#10;            if (!dpadUpPressed) dpadUpPressed = Input.GetKeyDown(KeyCode.UpArrow); // Flecha arriba del teclado&#10;            &#10;            // Eje 7 para D-pad vertical SOLAMENTE (NO usa joystick izquierdo)&#10;            // El eje &quot;7th axis&quot; es específico del D-Pad en la mayoría de los mandos&#10;            float dpadVertical = 0f;&#10;            try { dpadVertical = Input.GetAxis(&quot;7th axis&quot;); } catch { }&#10;            &#10;            // Detectar solo cuando se presiona (transición de no presionado a presionado)&#10;            if (!dpadUpPressed &amp;&amp; dpadVertical &gt; 0.5f &amp;&amp; !_lastFrameDpadUp)&#10;            {&#10;                dpadUpPressed = true;&#10;            }&#10;        }&#10;        &#10;        if (dpadUpPressed)&#10;        {&#10;            TogglePanel();&#10;        }&#10;        &#10;        // Guardar estado anterior del D-Pad (eje 7, NO el joystick)&#10;        float currentDpad = 0f;&#10;        try { currentDpad = Input.GetAxis(&quot;7th axis&quot;); } catch { }&#10;        _lastFrameDpadUp = currentDpad &gt; 0.5f;&#10;    }&#10;&#10;    private bool _lastFrameDpadUp = false;&#10;&#10;    IEnumerator BindWhenReady()&#10;    {&#10;        // Espera a que QuestManager exista (creado por tu escena Start)&#10;        while (QuestManager.Instance == null) yield return null;&#10;&#10;        // Si cambió de instancia (p.ej. reload), re-suscribe limpio&#10;        if (_qm != QuestManager.Instance)&#10;        {&#10;            Unbind();&#10;            _qm = QuestManager.Instance;&#10;            _qm.OnQuestsChanged += Rebuild;&#10;            _bound = true;&#10;        }&#10;&#10;        Rebuild();&#10;    }&#10;&#10;    void Unbind()&#10;    {&#10;        if (_bound &amp;&amp; _qm != null)&#10;        {&#10;            _qm.OnQuestsChanged -= Rebuild;&#10;        }&#10;        _bound = false;&#10;        _qm = null;&#10;    }&#10;&#10;    public void Rebuild()&#10;    {&#10;        if (!contentRoot || itemPrefab == null) return;&#10;        if (QuestManager.Instance == null) return; // por si se descargó la escena&#10;&#10;        // limpiar&#10;        for (int i = contentRoot.childCount - 1; i &gt;= 0; i--)&#10;            Destroy(contentRoot.GetChild(i).gameObject);&#10;&#10;        // poblar&#10;        foreach (var rq in QuestManager.Instance.GetAll())&#10;        {&#10;            if (!showInactive &amp;&amp; rq.State == QuestState.Inactive) continue;&#10;            var go = Instantiate(itemPrefab, contentRoot);&#10;            go.Bind(rq); // el propio item gestiona nulls internos&#10;        }&#10;&#10;        if (headerText) headerText.text = &quot;Misiones&quot;;&#10;    }&#10;&#10;    public void TogglePanel()&#10;    {&#10;        _isPanelVisible = !_isPanelVisible;&#10;        &#10;        // Solo ocultar el ScrollView, no todo el panel&#10;        if (scrollView)&#10;        {&#10;            scrollView.SetActive(_isPanelVisible);&#10;        }&#10;        &#10;        // Actualizar el texto de ayuda según el estado&#10;        if (helpText)&#10;        {&#10;            if (_isPanelVisible)&#10;            {&#10;                helpText.text = &quot;[D-Pad ▲] Ocultar&quot;;&#10;            }&#10;            else&#10;            {&#10;                helpText.text = &quot;[D-Pad ▲] Mostrar&quot;;&#10;            }&#10;        }&#10;    }&#10;&#10;    public void ShowPanel(bool show)&#10;    {&#10;        _isPanelVisible = show;&#10;        &#10;        if (scrollView)&#10;        {&#10;            scrollView.SetActive(_isPanelVisible);&#10;        }&#10;        &#10;        if (helpText)&#10;        {&#10;            if (_isPanelVisible)&#10;            {&#10;                helpText.text = &quot;[D-Pad ▲] Ocultar&quot;;&#10;            }&#10;            else&#10;            {&#10;                helpText.text = &quot;[D-Pad ▲] Mostrar&quot;;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Quests/QuestManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Quests/QuestManager.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System;&#10;&#10;public class QuestManager : MonoBehaviour&#10;{&#10;    public static QuestManager Instance { get; private set; }&#10;&#10;    [SerializeField] private List&lt;QuestData&gt; questCatalog = new(); // opcional: catálogo global&#10;    private readonly Dictionary&lt;string, RuntimeQuest&gt; runtime = new();&#10;&#10;    public event Action OnQuestsChanged;&#10;&#10;    void Awake()&#10;    {&#10;        if (Instance != null) { Destroy(gameObject); return; }&#10;        Instance = this;&#10;        DontDestroyOnLoad(gameObject);&#10;    }&#10;&#10;    public bool HasQuest(string questId) =&gt; runtime.ContainsKey(questId);&#10;    public QuestState GetState(string questId) =&gt; HasQuest(questId) ? runtime[questId].State : QuestState.Inactive;&#10;&#10;    public void AddQuest(QuestData data)&#10;    {&#10;        if (data == null || string.IsNullOrEmpty(data.questId)) return;&#10;        if (runtime.ContainsKey(data.questId)) return;&#10;&#10;        runtime[data.questId] = new RuntimeQuest(data);&#10;        OnQuestsChanged?.Invoke();&#10;    }&#10;&#10;    public void Activate(string questId)&#10;    {&#10;        if (!runtime.TryGetValue(questId, out var rq)) return;&#10;        if (rq.State == QuestState.Inactive) rq.State = QuestState.Active;&#10;        OnQuestsChanged?.Invoke();&#10;    }&#10;&#10;    public void CompleteStep(string questId, int index)&#10;    {&#10;        if (!runtime.TryGetValue(questId, out var rq)) return;&#10;        if (rq.State != QuestState.Active) return;&#10;&#10;        if (index &gt;= 0 &amp;&amp; index &lt; rq.Steps.Length)&#10;        {&#10;            rq.Steps[index].completed = true;&#10;&#10;            // Si todos los pasos están completados → misión completada.&#10;            if (rq.Steps.All(s =&gt; s.completed))&#10;                rq.State = QuestState.Completed;&#10;&#10;            OnQuestsChanged?.Invoke();&#10;        }&#10;    }&#10;&#10;    public void CompleteByCondition(string conditionId)&#10;    {&#10;        if (string.IsNullOrEmpty(conditionId)) return;&#10;&#10;        foreach (var rq in runtime.Values)&#10;        {&#10;            if (rq.State != QuestState.Active) continue;&#10;            for (int i = 0; i &lt; rq.Steps.Length; i++)&#10;            {&#10;                var step = rq.Steps[i];&#10;                if (!step.completed &amp;&amp; step.conditionId == conditionId)&#10;                {&#10;                    CompleteStep(rq.Id, i);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public IEnumerable&lt;RuntimeQuest&gt; GetAll() =&gt; runtime.Values;&#10;&#10;    // ===== Runtime model =====&#10;    public class RuntimeQuest&#10;    {&#10;        public string Id =&gt; Data.questId;&#10;        public QuestData Data { get; }&#10;        public QuestState State { get; set; }&#10;        public QuestStep[] Steps { get; }&#10;&#10;        public RuntimeQuest(QuestData data)&#10;        {&#10;            Data = data;&#10;            State = QuestState.Inactive;&#10;            // Copia profunda ligera de pasos para estado en runtime&#10;            Steps = data.steps != null ? data.steps.Select(s =&gt; new QuestStep {&#10;                description = s.description, conditionId = s.conditionId, completed = false&#10;            }).ToArray() : new QuestStep[0];&#10;        }&#10;    }&#10;    &#10;    public void StartQuest(string questId)&#10;    {&#10;        if (!runtime.TryGetValue(questId, out var rq))&#10;        {&#10;            var data = questCatalog.FirstOrDefault(q =&gt; q.questId == questId);&#10;            if (data == null) return;&#10;            rq = new RuntimeQuest(data);&#10;            runtime[questId] = rq;&#10;        }&#10;        if (rq.State == QuestState.Inactive) rq.State = QuestState.Active;&#10;        OnQuestsChanged?.Invoke();&#10;    }&#10;&#10;    public bool AreAllStepsCompleted(string questId)&#10;    {&#10;        if (!runtime.TryGetValue(questId, out var rq)) return false;&#10;        if (rq.Steps == null || rq.Steps.Length == 0) return true;&#10;        foreach (var s in rq.Steps) if (!s.completed) return false;&#10;        return true;&#10;    }&#10;&#10;    public void CompleteQuest(string questId)&#10;    {&#10;        if (!runtime.TryGetValue(questId, out var rq)) return;&#10;        rq.State = QuestState.Completed;&#10;        OnQuestsChanged?.Invoke();&#10;    }&#10;    &#10;    public void MarkStepDone(string questId, int stepIndex)&#10;    {&#10;        if (!runtime.TryGetValue(questId, out var rq)) return;&#10;        if (stepIndex &lt; 0 || stepIndex &gt;= rq.Steps.Length) return;&#10;        rq.Steps[stepIndex].completed = true;&#10;        OnQuestsChanged?.Invoke();&#10;    }&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System;&#10;&#10;public class QuestManager : MonoBehaviour&#10;{&#10;    public static QuestManager Instance { get; private set; }&#10;&#10;    [SerializeField] private List&lt;QuestData&gt; questCatalog = new(); // opcional: catálogo global&#10;    private readonly Dictionary&lt;string, RuntimeQuest&gt; runtime = new();&#10;&#10;    public event Action OnQuestsChanged;&#10;&#10;    void Awake()&#10;    {&#10;        if (Instance != null) { Destroy(gameObject); return; }&#10;        Instance = this;&#10;        DontDestroyOnLoad(gameObject);&#10;    }&#10;&#10;    public bool HasQuest(string questId) =&gt; runtime.ContainsKey(questId);&#10;    public QuestState GetState(string questId) =&gt; HasQuest(questId) ? runtime[questId].State : QuestState.Inactive;&#10;&#10;    public void AddQuest(QuestData data)&#10;    {&#10;        if (data == null || string.IsNullOrEmpty(data.questId)) return;&#10;        if (runtime.ContainsKey(data.questId)) return;&#10;&#10;        runtime[data.questId] = new RuntimeQuest(data);&#10;        OnQuestsChanged?.Invoke();&#10;    }&#10;&#10;    public void Activate(string questId)&#10;    {&#10;        if (!runtime.TryGetValue(questId, out var rq)) return;&#10;        if (rq.State == QuestState.Inactive) rq.State = QuestState.Active;&#10;        OnQuestsChanged?.Invoke();&#10;    }&#10;&#10;    public void CompleteStep(string questId, int index)&#10;    {&#10;        if (!runtime.TryGetValue(questId, out var rq)) return;&#10;        if (rq.State != QuestState.Active) return;&#10;&#10;        if (index &gt;= 0 &amp;&amp; index &lt; rq.Steps.Length)&#10;        {&#10;            rq.Steps[index].completed = true;&#10;&#10;            // Si todos los pasos están completados → misión completada.&#10;            if (rq.Steps.All(s =&gt; s.completed))&#10;                rq.State = QuestState.Completed;&#10;&#10;            OnQuestsChanged?.Invoke();&#10;        }&#10;    }&#10;&#10;    public void CompleteByCondition(string conditionId)&#10;    {&#10;        if (string.IsNullOrEmpty(conditionId)) return;&#10;&#10;        foreach (var rq in runtime.Values)&#10;        {&#10;            if (rq.State != QuestState.Active) continue;&#10;            for (int i = 0; i &lt; rq.Steps.Length; i++)&#10;            {&#10;                var step = rq.Steps[i];&#10;                if (!step.completed &amp;&amp; step.conditionId == conditionId)&#10;                {&#10;                    CompleteStep(rq.Id, i);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public IEnumerable&lt;RuntimeQuest&gt; GetAll() =&gt; runtime.Values;&#10;&#10;    // ===== Runtime model =====&#10;    public class RuntimeQuest&#10;    {&#10;        public string Id =&gt; Data.questId;&#10;        public QuestData Data { get; }&#10;        public QuestState State { get; set; }&#10;        public QuestStep[] Steps { get; }&#10;&#10;        public RuntimeQuest(QuestData data)&#10;        {&#10;            Data = data;&#10;            State = QuestState.Inactive;&#10;            // Copia profunda ligera de pasos para estado en runtime&#10;            Steps = data.steps != null ? data.steps.Select(s =&gt; new QuestStep {&#10;                description = s.description, conditionId = s.conditionId, completed = false&#10;            }).ToArray() : new QuestStep[0];&#10;        }&#10;    }&#10;    &#10;    public void StartQuest(string questId)&#10;    {&#10;        if (!runtime.TryGetValue(questId, out var rq))&#10;        {&#10;            var data = questCatalog.FirstOrDefault(q =&gt; q.questId == questId);&#10;            if (data == null) return;&#10;            rq = new RuntimeQuest(data);&#10;            runtime[questId] = rq;&#10;        }&#10;        if (rq.State == QuestState.Inactive) rq.State = QuestState.Active;&#10;        OnQuestsChanged?.Invoke();&#10;    }&#10;&#10;    public bool AreAllStepsCompleted(string questId)&#10;    {&#10;        if (!runtime.TryGetValue(questId, out var rq)) return false;&#10;        if (rq.Steps == null || rq.Steps.Length == 0) return true;&#10;        foreach (var s in rq.Steps) if (!s.completed) return false;&#10;        return true;&#10;    }&#10;&#10;    public void CompleteQuest(string questId)&#10;    {&#10;        if (!runtime.TryGetValue(questId, out var rq)) return;&#10;        rq.State = QuestState.Completed;&#10;        OnQuestsChanged?.Invoke();&#10;    }&#10;    &#10;    public void MarkStepDone(string questId, int stepIndex)&#10;    {&#10;        if (!runtime.TryGetValue(questId, out var rq)) return;&#10;        if (stepIndex &lt; 0 || stepIndex &gt;= rq.Steps.Length) return;&#10;        rq.Steps[stepIndex].completed = true;&#10;        OnQuestsChanged?.Invoke();&#10;    }&#10;&#10;    public bool IsStepCompleted(string questId, int stepIndex)&#10;    {&#10;        if (!runtime.TryGetValue(questId, out var rq)) return false;&#10;        if (stepIndex &lt; 0 || stepIndex &gt;= rq.Steps.Length) return false;&#10;        return rq.Steps[stepIndex].completed;&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>