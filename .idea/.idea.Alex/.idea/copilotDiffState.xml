<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Cinematics/AdditiveSceneCinematic.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Cinematics/AdditiveSceneCinematic.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using UnityEngine.Playables;&#10;using System.Collections;&#10;&#10;public class AdditiveSceneCinematic : MonoBehaviour&#10;{&#10;    [Header(&quot;Cinematic Scene&quot;)]&#10;    [SerializeField] private string cinematicSceneName = &quot;&quot;;   // usado en runtime&#10;&#10;#if UNITY_EDITOR&#10;    [SerializeField] private UnityEditor.SceneAsset cinematicSceneAsset; // solo para drag&amp;drop en editor&#10;    void OnValidate()&#10;    {&#10;        if (cinematicSceneAsset != null)&#10;            cinematicSceneName = cinematicSceneAsset.name; // copiamos el nombre real de la escena&#10;    }&#10;#endif&#10;&#10;    [Header(&quot;Playback&quot;)]&#10;    [SerializeField] private bool playOnStart = true;&#10;    [SerializeField] private bool directorInAdditive = true;&#10;&#10;    [Header(&quot;Gameplay Lock&quot;)]&#10;    [SerializeField] private GameObject[] toDisableDuringCinematic;&#10;&#10;    [Header(&quot;Debug&quot;)]&#10;    [SerializeField] private bool showDebugLogs = true;&#10;&#10;    AsyncOperation loadOp;&#10;    PlayableDirector director;&#10;    bool isUnloading = false;&#10;    bool isPlaying = false;&#10;    Coroutine watchdogCo;&#10;&#10;    IEnumerator Start()&#10;    {&#10;        if (!playOnStart) yield break;&#10;        yield return Play();&#10;    }&#10;&#10;    public IEnumerator Play()&#10;    {&#10;        if (string.IsNullOrEmpty(cinematicSceneName))&#10;        {&#10;            Debug.LogWarning(&quot;[AdditiveSceneCinematic] No hay escena asignada.&quot;);&#10;            yield break;&#10;        }&#10;&#10;        isUnloading = false;&#10;        isPlaying = false;&#10;&#10;        if (showDebugLogs)&#10;            Debug.Log($&quot;[AdditiveSceneCinematic] Desactivando gameplay y cargando escena: {cinematicSceneName}&quot;);&#10;&#10;        if (toDisableDuringCinematic != null)&#10;            foreach (var go in toDisableDuringCinematic) if (go) go.SetActive(false);&#10;&#10;        loadOp = SceneManager.LoadSceneAsync(cinematicSceneName, LoadSceneMode.Additive);&#10;        yield return loadOp;&#10;&#10;        if (directorInAdditive)&#10;        {&#10;            var scn = SceneManager.GetSceneByName(cinematicSceneName);&#10;            foreach (var root in scn.GetRootGameObjects())&#10;            {&#10;                director = director ?? root.GetComponentInChildren&lt;PlayableDirector&gt;(true);&#10;                if (director) break;&#10;            }&#10;        }&#10;        else&#10;        {&#10;            director = GetComponentInChildren&lt;PlayableDirector&gt;(true);&#10;        }&#10;&#10;        if (director)&#10;        {&#10;            // Limpieza previa + subscribir&#10;            director.stopped -= OnDirectorStopped;&#10;            director.stopped += OnDirectorStopped;&#10;&#10;            // Clave: forzar finalización real (emite 'stopped')&#10;            director.extrapolationMode = DirectorWrapMode.None;&#10;&#10;            if (showDebugLogs)&#10;                Debug.Log($&quot;[AdditiveSceneCinematic] PlayableDirector encontrado. Duración: {director.duration:F2}s. Iniciando reproducción...&quot;);&#10;&#10;            director.Play();&#10;            isPlaying = true;&#10;&#10;            // Watchdog: si no llega 'stopped', forzamos Stop()&#10;            if (watchdogCo != null) StopCoroutine(watchdogCo);&#10;            watchdogCo = StartCoroutine(WatchDirectorEnd(director));&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[AdditiveSceneCinematic] No se encontró PlayableDirector; descargando escena.&quot;);&#10;            yield return Unload();&#10;        }&#10;    }&#10;&#10;    IEnumerator WatchDirectorEnd(PlayableDirector d)&#10;    {&#10;        float Elapsed() =&gt; d.timeUpdateMode == DirectorUpdateMode.GameTime ? Time.deltaTime : Time.unscaledDeltaTime;&#10;&#10;        var target = Mathf.Max(0.05f, (float)d.duration) + 0.25f;&#10;        float t = 0f;&#10;&#10;        while (d != null &amp;&amp; !isUnloading &amp;&amp; d.state == PlayState.Playing)&#10;        {&#10;            t += Elapsed();&#10;&#10;            if (d.time &gt;= d.duration - 0.001f)&#10;                break;&#10;&#10;            if (t &gt;= target)&#10;                break;&#10;&#10;            yield return null;&#10;        }&#10;&#10;        if (d != null &amp;&amp; !isUnloading &amp;&amp; d.state == PlayState.Playing)&#10;        {&#10;            if (showDebugLogs)&#10;                Debug.Log(&quot;[AdditiveSceneCinematic] Watchdog forzando Stop() de la Timeline.&quot;);&#10;            d.Stop(); // disparará OnDirectorStopped&#10;        }&#10;    }&#10;&#10;    void Update()&#10;    {&#10;        // Respaldo por si el wrapMode se tocó en runtime&#10;        if (isPlaying &amp;&amp; director != null &amp;&amp; !isUnloading)&#10;        {&#10;            if (director.time &gt;= director.duration &amp;&amp; director.state != PlayState.Playing)&#10;            {&#10;                if (showDebugLogs)&#10;                    Debug.Log($&quot;[AdditiveSceneCinematic] Timeline terminó detectado en Update. {director.time:F2}s / {director.duration:F2}s&quot;);&#10;                isPlaying = false;&#10;                director.stopped -= OnDirectorStopped;&#10;                StartCoroutine(Unload());&#10;            }&#10;        }&#10;    }&#10;&#10;    void OnDirectorStopped(PlayableDirector d)&#10;    {&#10;        if (isUnloading)&#10;        {&#10;            if (showDebugLogs)&#10;                Debug.Log(&quot;[AdditiveSceneCinematic] Ya está descargando, ignorando llamada duplicada.&quot;);&#10;            return;&#10;        }&#10;&#10;        if (showDebugLogs)&#10;            Debug.Log($&quot;[AdditiveSceneCinematic] Director detenido ({d.time:F2}s / {d.duration:F2}s). Iniciando descarga...&quot;);&#10;&#10;        isPlaying = false;&#10;        d.stopped -= OnDirectorStopped;&#10;        StartCoroutine(Unload());&#10;    }&#10;&#10;    IEnumerator Unload()&#10;    {&#10;        if (isUnloading)&#10;        {&#10;            if (showDebugLogs)&#10;                Debug.Log(&quot;[AdditiveSceneCinematic] Ya está descargando.&quot;);&#10;            yield break;&#10;        }&#10;&#10;        isUnloading = true;&#10;        isPlaying = false;&#10;&#10;        if (watchdogCo != null) { StopCoroutine(watchdogCo); watchdogCo = null; }&#10;&#10;        if (showDebugLogs)&#10;            Debug.Log($&quot;[AdditiveSceneCinematic] Descargando escena: {cinematicSceneName}&quot;);&#10;&#10;        var scn = SceneManager.GetSceneByName(cinematicSceneName);&#10;        if (scn.isLoaded)&#10;            yield return SceneManager.UnloadSceneAsync(scn);&#10;&#10;        if (showDebugLogs)&#10;            Debug.Log(&quot;[AdditiveSceneCinematic] Reactivando gameplay.&quot;);&#10;&#10;        if (toDisableDuringCinematic != null)&#10;            foreach (var go in toDisableDuringCinematic) if (go) go.SetActive(true);&#10;&#10;        director = null;&#10;        isUnloading = false;&#10;    }&#10;&#10;    void OnDestroy()&#10;    {&#10;        if (director != null)&#10;            director.stopped -= OnDirectorStopped;&#10;        if (watchdogCo != null)&#10;            StopCoroutine(watchdogCo);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using UnityEngine.Playables;&#10;using System.Collections;&#10;&#10;public class AdditiveSceneCinematic : MonoBehaviour&#10;{&#10;    [Header(&quot;Cinematic Scene&quot;)]&#10;    [SerializeField] private string cinematicSceneName = &quot;&quot;;   // usado en runtime&#10;&#10;#if UNITY_EDITOR&#10;    [SerializeField] private UnityEditor.SceneAsset cinematicSceneAsset; // solo para drag&amp;drop en editor&#10;    void OnValidate()&#10;    {&#10;        if (cinematicSceneAsset != null)&#10;            cinematicSceneName = cinematicSceneAsset.name; // copiamos el nombre real de la escena&#10;    }&#10;#endif&#10;&#10;    [Header(&quot;Playback&quot;)]&#10;    [SerializeField] private bool playOnStart = true;&#10;    [SerializeField] private bool directorInAdditive = true;&#10;&#10;    [Header(&quot;Gameplay Lock&quot;)]&#10;    [SerializeField] private GameObject[] toDisableDuringCinematic;&#10;&#10;    [Header(&quot;Debug&quot;)]&#10;    [SerializeField] private bool showDebugLogs = true;&#10;&#10;    AsyncOperation loadOp;&#10;    PlayableDirector director;&#10;    bool isUnloading = false;&#10;    bool isPlaying = false;&#10;    Coroutine watchdogCo;&#10;&#10;    IEnumerator Start()&#10;    {&#10;        if (!playOnStart) yield break;&#10;        yield return Play();&#10;    }&#10;&#10;    public IEnumerator Play()&#10;    {&#10;        if (string.IsNullOrEmpty(cinematicSceneName))&#10;        {&#10;            Debug.LogWarning(&quot;[AdditiveSceneCinematic] No hay escena asignada.&quot;);&#10;            yield break;&#10;        }&#10;&#10;        isUnloading = false;&#10;        isPlaying = false;&#10;&#10;        if (showDebugLogs)&#10;            Debug.Log($&quot;[AdditiveSceneCinematic] Desactivando gameplay y cargando escena: {cinematicSceneName}&quot;);&#10;&#10;        if (toDisableDuringCinematic != null)&#10;            foreach (var go in toDisableDuringCinematic) if (go) go.SetActive(false);&#10;&#10;        loadOp = SceneManager.LoadSceneAsync(cinematicSceneName, LoadSceneMode.Additive);&#10;        yield return loadOp;&#10;&#10;        if (directorInAdditive)&#10;        {&#10;            var scn = SceneManager.GetSceneByName(cinematicSceneName);&#10;            foreach (var root in scn.GetRootGameObjects())&#10;            {&#10;                director = director ?? root.GetComponentInChildren&lt;PlayableDirector&gt;(true);&#10;                if (director) break;&#10;            }&#10;        }&#10;        else&#10;        {&#10;            director = GetComponentInChildren&lt;PlayableDirector&gt;(true);&#10;        }&#10;&#10;        if (director)&#10;        {&#10;            // Limpieza previa + subscribir&#10;            director.stopped -= OnDirectorStopped;&#10;            director.stopped += OnDirectorStopped;&#10;&#10;            // Clave: forzar finalización real (emite 'stopped')&#10;            director.extrapolationMode = DirectorWrapMode.None;&#10;&#10;            if (showDebugLogs)&#10;                Debug.Log($&quot;[AdditiveSceneCinematic] PlayableDirector encontrado. Duración: {director.duration:F2}s. Iniciando reproducción...&quot;);&#10;&#10;            director.Play();&#10;            isPlaying = true;&#10;&#10;            // Watchdog: si no llega 'stopped', forzamos Stop()&#10;            if (watchdogCo != null) StopCoroutine(watchdogCo);&#10;            watchdogCo = StartCoroutine(WatchDirectorEnd(director));&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;[AdditiveSceneCinematic] No se encontró PlayableDirector; descargando escena.&quot;);&#10;            yield return Unload();&#10;        }&#10;    }&#10;&#10;    IEnumerator WatchDirectorEnd(PlayableDirector d)&#10;    {&#10;        float Elapsed() =&gt; d.timeUpdateMode == DirectorUpdateMode.GameTime ? Time.deltaTime : Time.unscaledDeltaTime;&#10;&#10;        var target = Mathf.Max(0.05f, (float)d.duration) + 0.25f;&#10;        float t = 0f;&#10;&#10;        while (d != null &amp;&amp; !isUnloading &amp;&amp; d.state == PlayState.Playing)&#10;        {&#10;            t += Elapsed();&#10;&#10;            if (d.time &gt;= d.duration - 0.001f)&#10;                break;&#10;&#10;            if (t &gt;= target)&#10;                break;&#10;&#10;            yield return null;&#10;        }&#10;&#10;        if (d != null &amp;&amp; !isUnloading &amp;&amp; d.state == PlayState.Playing)&#10;        {&#10;            if (showDebugLogs)&#10;                Debug.Log(&quot;[AdditiveSceneCinematic] Watchdog forzando Stop() de la Timeline.&quot;);&#10;            d.Stop(); // disparará OnDirectorStopped&#10;        }&#10;    }&#10;&#10;    void Update()&#10;    {&#10;        // Respaldo por si el wrapMode se tocó en runtime&#10;        if (isPlaying &amp;&amp; director != null &amp;&amp; !isUnloading)&#10;        {&#10;            if (director.time &gt;= director.duration &amp;&amp; director.state != PlayState.Playing)&#10;            {&#10;                if (showDebugLogs)&#10;                    Debug.Log($&quot;[AdditiveSceneCinematic] Timeline terminó detectado en Update. {director.time:F2}s / {director.duration:F2}s&quot;);&#10;                isPlaying = false;&#10;                director.stopped -= OnDirectorStopped;&#10;                StartCoroutine(Unload());&#10;            }&#10;        }&#10;    }&#10;&#10;    void OnDirectorStopped(PlayableDirector d)&#10;    {&#10;        if (isUnloading)&#10;        {&#10;            if (showDebugLogs)&#10;                Debug.Log(&quot;[AdditiveSceneCinematic] Ya está descargando, ignorando llamada duplicada.&quot;);&#10;            return;&#10;        }&#10;&#10;        if (showDebugLogs)&#10;            Debug.Log($&quot;[AdditiveSceneCinematic] Director detenido ({d.time:F2}s / {d.duration:F2}s). Iniciando descarga...&quot;);&#10;&#10;        isPlaying = false;&#10;        d.stopped -= OnDirectorStopped;&#10;        StartCoroutine(Unload());&#10;    }&#10;&#10;    IEnumerator Unload()&#10;    {&#10;        if (isUnloading)&#10;        {&#10;            if (showDebugLogs)&#10;                Debug.Log(&quot;[AdditiveSceneCinematic] Ya está descargando.&quot;);&#10;            yield break;&#10;        }&#10;&#10;        isUnloading = true;&#10;        isPlaying = false;&#10;&#10;        if (watchdogCo != null) { StopCoroutine(watchdogCo); watchdogCo = null; }&#10;&#10;        if (showDebugLogs)&#10;            Debug.Log($&quot;[AdditiveSceneCinematic] Descargando escena: {cinematicSceneName}&quot;);&#10;&#10;        var scn = SceneManager.GetSceneByName(cinematicSceneName);&#10;        if (scn.isLoaded)&#10;            yield return SceneManager.UnloadSceneAsync(scn);&#10;&#10;        // Esperar un frame extra para evitar parpadeo visual&#10;        yield return null;&#10;&#10;        if (showDebugLogs)&#10;            Debug.Log(&quot;[AdditiveSceneCinematic] Reactivando gameplay.&quot;);&#10;&#10;        if (toDisableDuringCinematic != null)&#10;            foreach (var go in toDisableDuringCinematic) if (go) go.SetActive(true);&#10;&#10;        director = null;&#10;        isUnloading = false;&#10;    }&#10;&#10;    void OnDestroy()&#10;    {&#10;        if (director != null)&#10;            director.stopped -= OnDirectorStopped;&#10;        if (watchdogCo != null)&#10;            StopCoroutine(watchdogCo);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Dialogue/DialogueCameraController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Dialogue/DialogueCameraController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System.Collections;&#10;&#10;/// &lt;summary&gt;&#10;/// Controla la cámara durante los diálogos para enfocar la conversación entre el NPC y Alex&#10;/// &lt;/summary&gt;&#10;public class DialogueCameraController : MonoBehaviour&#10;{&#10;    public static DialogueCameraController Instance { get; private set; }&#10;&#10;    [Header(&quot;Referencias&quot;)]&#10;    [SerializeField] private vThirdPersonCamera thirdPersonCamera;&#10;&#10;    [Header(&quot;Configuración de Cámara de Diálogo&quot;)]&#10;    [Tooltip(&quot;Distancia desde el punto medio entre el player y el NPC&quot;)]&#10;    [SerializeField] private float dialogueDistance = 3.5f;&#10;    &#10;    [Tooltip(&quot;Altura adicional de la cámara durante el diálogo&quot;)]&#10;    [SerializeField] private float dialogueHeight = 1.5f;&#10;    &#10;    [Tooltip(&quot;Velocidad de transición de la cámara&quot;)]&#10;    [SerializeField] private float transitionSpeed = 2f;&#10;    &#10;    [Tooltip(&quot;Si está activo, hace que el player rote para mirar al NPC&quot;)]&#10;    [SerializeField] private bool rotatePlayerToNPC = true;&#10;&#10;    [Header(&quot;Debug&quot;)]&#10;    [SerializeField] private bool showDebugLogs = false;&#10;&#10;    // Estado&#10;    private bool isInDialogueMode = false;&#10;&#10;    [Tooltip(&quot;Desplazamiento lateral para crear ángulo cinematográfico&quot;)]&#10;    [SerializeField] private float lateralOffset = 1.5f;&#10;    private Vector3 targetCameraPosition;&#10;    private Quaternion targetCameraRotation;&#10;    private Vector3 originalCameraLocalPosition;&#10;    private Quaternion originalPlayerRotation;&#10;    private bool wasLocked = false;&#10;    private Coroutine transitionCoroutine;&#10;&#10;    void Awake()&#10;    {&#10;        if (Instance != null) &#10;        { &#10;    private Vector3 originalCameraPosition;&#10;    private Quaternion originalCameraRotation;&#10;&#10;    void Start()&#10;    {&#10;        // Buscar la cámara si no está asignada&#10;        if (thirdPersonCamera == null)&#10;        {&#10;            thirdPersonCamera = FindFirstObjectByType&lt;vThirdPersonCamera&gt;();&#10;        }&#10;        &#10;        if (thirdPersonCamera != null)&#10;        {&#10;        DontDestroyOnLoad(gameObject);&#10;            mainCamera = thirdPersonCamera.GetComponent&lt;Camera&gt;();&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Inicia el modo de cámara de diálogo mostrando al player de perfil mirando al NPC&#10;    /// &lt;/summary&gt;&#10;    public void StartDialogueCamera(Transform npcTransform)&#10;    {&#10;        if (!enableDialogueCamera || npcTransform == null || isInDialogueMode) return;&#10;            thirdPersonCamera = FindObjectOfType&lt;vThirdPersonCamera&gt;();&#10;                Debug.LogWarning(&quot;[DialogueCameraController] No se encontró el player.&quot;);&#10;            return;&#10;        }&#10;    /// Inicia el modo de cámara de diálogo enfocando al NPC y al player&#10;        player = playerObj.transform;&#10;        currentNPC = npcTransform;&#10;        isInDialogueMode = true;&#10;&#10;        // Buscar la cámara si aún no está asignada&#10;        if (thirdPersonCamera == null)&#10;    /// &lt;param name=&quot;npcTransform&quot;&gt;Transform del NPC con el que se está hablando&lt;/param&gt;&#10;        {&#10;            thirdPersonCamera = FindFirstObjectByType&lt;vThirdPersonCamera&gt;();&#10;        if (npcTransform == null || isInDialogueMode) return;&#10;&#10;        GameObject playerObj = GameObject.FindWithTag(&quot;Player&quot;);&#10;        {&#10;            if (showDebugLogs)&#10;                Debug.LogWarning(&quot;[DialogueCameraController] No se encontró vThirdPersonCamera.&quot;);&#10;            return;&#10;        }&#10;&#10;        if (mainCamera == null)&#10;        {&#10;            mainCamera = thirdPersonCamera.GetComponent&lt;Camera&gt;();&#10;        }&#10;&#10;        // Guardar estado original&#10;        wasLocked = thirdPersonCamera.lockCamera;&#10;        if (mainCamera != null)&#10;            thirdPersonCamera = FindObjectOfType&lt;vThirdPersonCamera&gt;();&#10;            originalCameraLocalPosition = mainCamera.transform.localPosition;&#10;        }&#10;        originalPlayerRotation = player.rotation;&#10;        &#10;        // Bloquear la cámara para que el jugador no pueda moverla&#10;        thirdPersonCamera.lockCamera = true;&#10;&#10;        // Rotar el player hacia el NPC si está habilitado&#10;        if (rotatePlayerToNPC)&#10;                player.rotation = Quaternion.LookRotation(directionToNPC);&#10;            }&#10;        &#10;        // Iniciar transición suave&#10;        if (transitionCoroutine != null)&#10;            StopCoroutine(transitionCoroutine);&#10;        transitionCoroutine = StartCoroutine(TransitionToDialogueCamera());&#10;    }&#10;&#10;        {&#10;            thirdPersonCamera.lockCamera = wasLocked;&#10;        }&#10;&#10;        // Restaurar posición local de la cámara&#10;        if (mainCamera != null &amp;&amp; transitionCoroutine != null)&#10;        {&#10;            StopCoroutine(transitionCoroutine);&#10;            transitionCoroutine = StartCoroutine(TransitionBackToNormal());&#10;        }&#10;        // Iniciar transición de cámara&#10;            player = null;&#10;        }&#10;    }&#10;&#10;    private void CalculateDialogueCameraTransform()&#10;    {&#10;        if (player == null || currentNPC == null) return;&#10;&#10;        // Dirección del player al NPC (en el plano horizontal)&#10;        Vector3 directionToNPC = (currentNPC.position - player.position);&#10;        directionToNPC.y = 0;&#10;        directionToNPC.Normalize();&#10;&#10;        // Perpendicular a la derecha para posicionar la cámara lateral&#10;        Vector3 rightDirection = Vector3.Cross(Vector3.up, directionToNPC).normalized;&#10;&#10;        // Posición de la cámara: a un lado del player, un poco atrás y elevada&#10;        Vector3 sidePosition = player.position + rightDirection * sideDistance;&#10;        Vector3 backOffset = -directionToNPC * backDistance;&#10;        Vector3 heightPosition = Vector3.up * (player.position.y + heightOffset + 1.5f);&#10;&#10;        targetCameraPosition = sidePosition + backOffset;&#10;        targetCameraPosition.y = heightPosition.y;&#10;&#10;        // La cámara mira hacia el punto medio entre el player y el NPC&#10;        Vector3 lookAtPoint = (player.position + currentNPC.position) / 2f;&#10;        lookAtPoint.y += 1.5f; // A la altura de las caras&#10;&#10;        targetCameraRotation = Quaternion.LookRotation(lookAtPoint - targetCameraPosition);&#10;&#10;        // Aplicar inclinación vertical y rotación horizontal&#10;        if (transitionCoroutine != null)&#10;        {&#10;            Debug.DrawLine(player.position, currentNPC.position, Color.yellow, 2f);&#10;            Debug.DrawLine(targetCameraPosition, lookAtPoint, Color.cyan, 2f);&#10;        }&#10;&#10;        isInDialogueMode = false;&#10;        currentNPC = null;&#10;        player = null;&#10;&#10;        float elapsed = 0f;&#10;        float duration = 1f / transitionSpeed;&#10;        Quaternion targetRot = Quaternion.LookRotation(player.position - targetPos);&#10;&#10;        float elapsed = 0f;&#10;        float duration = 0.8f / transitionSpeed;&#10;&#10;        while (elapsed &lt; duration)&#10;        {&#10;        Camera mainCamera = thirdPersonCamera.GetComponent&lt;Camera&gt;();&#10;            elapsed += Time.deltaTime;&#10;            float t = Mathf.SmoothStep(0f, 1f, elapsed / duration);&#10;&#10;            mainCamera.transform.position = Vector3.Lerp(startPos, targetPos, t);&#10;            mainCamera.transform.rotation = Quaternion.Slerp(startRot, targetRot, t);&#10;&#10;            yield return null;&#10;        }&#10;&#10;        isInDialogueMode = false;&#10;        currentNPC = null;&#10;        player = null;&#10;        transitionCoroutine = null;&#10;    }&#10;&#10;    void LateUpdate()&#10;    {&#10;        // Mantener la cámara en posición de diálogo mientras esté activa&#10;        if (isInDialogueMode &amp;&amp; currentNPC != null &amp;&amp; player != null &amp;&amp; mainCamera != null &amp;&amp; transitionCoroutine == null)&#10;        {&#10;            // Recalcular por si el player o NPC se movieron&#10;            CalculateDialogueCameraTransform();&#10;            &#10;            // Aplicar con suavizado ligero para compensar movimientos pequeños&#10;            mainCamera.transform.position = Vector3.Lerp(mainCamera.transform.position, targetCameraPosition, Time.deltaTime * 5f);&#10;            mainCamera.transform.rotation = Quaternion.Slerp(mainCamera.transform.rotation, targetCameraRotation, Time.deltaTime * 5f);&#10;        }&#10;    }&#10;&#10;    void OnDrawGizmosSelected()&#10;    {&#10;        if (isInDialogueMode &amp;&amp; currentNPC != null &amp;&amp; player != null)&#10;        {&#10;            // Visualizar la configuración de la cámara&#10;            Gizmos.color = Color.yellow;&#10;            Gizmos.DrawLine(player.position + Vector3.up, currentNPC.position + Vector3.up);&#10;            &#10;            Gizmos.color = Color.cyan;&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#13;&#10;using System.Collections;&#13;&#10;&#13;&#10;/// &lt;summary&gt;&#13;&#10;/// Controla la cámara durante los diálogos para mostrar al player de perfil mirando al NPC&#13;&#10;/// &lt;/summary&gt;&#13;&#10;public class DialogueCameraController : MonoBehaviour&#13;&#10;{&#13;&#10;    public static DialogueCameraController Instance { get; private set; }&#13;&#10;&#13;&#10;    [Header(&quot;Referencias&quot;)]&#13;&#10;    [SerializeField] private vThirdPersonCamera thirdPersonCamera;&#13;&#10;&#13;&#10;    [Header(&quot;Configuración de Cámara de Diálogo&quot;)]&#13;&#10;    [Tooltip(&quot;Si está activo, mueve la cámara para mostrar al player de perfil&quot;)]&#13;&#10;    [SerializeField] private bool enableDialogueCamera = true;&#13;&#10;    &#13;&#10;    [Tooltip(&quot;Distancia lateral de la cámara respecto al player&quot;)]&#13;&#10;    [SerializeField] private float sideDistance = 2.5f;&#13;&#10;    &#13;&#10;    [Tooltip(&quot;Distancia hacia atrás desde la posición lateral&quot;)]&#13;&#10;    [SerializeField] private float backDistance = 1.5f;&#13;&#10;    &#13;&#10;    [Tooltip(&quot;Altura adicional de la cámara&quot;)]&#13;&#10;    [SerializeField] private float heightOffset = 0.3f;&#13;&#10;    &#13;&#10;    [Tooltip(&quot;Velocidad de transición de la cámara&quot;)]&#13;&#10;    [SerializeField] private float transitionSpeed = 2f;&#13;&#10;    &#13;&#10;    [Tooltip(&quot;Si está activo, hace que el player rote para mirar al NPC&quot;)]&#13;&#10;    [SerializeField] private bool rotatePlayerToNPC = true;&#13;&#10;&#13;&#10;    [Header(&quot;Debug&quot;)]&#13;&#10;    [SerializeField] private bool showDebugLogs = false;&#13;&#10;&#13;&#10;    // Estado&#13;&#10;    private bool isInDialogueMode = false;&#13;&#10;    private Transform currentNPC = null;&#13;&#10;    private Transform player = null;&#13;&#10;    private Camera mainCamera = null;&#13;&#10;    private Vector3 targetCameraPosition;&#13;&#10;    private Quaternion targetCameraRotation;&#13;&#10;    private Vector3 originalCameraLocalPosition;&#13;&#10;    private Quaternion originalPlayerRotation;&#13;&#10;    private bool wasLocked = false;&#13;&#10;    private Coroutine transitionCoroutine;&#13;&#10;&#13;&#10;    void Awake()&#13;&#10;    {&#13;&#10;        if (Instance != null) &#13;&#10;        { &#13;&#10;            Destroy(gameObject); &#13;&#10;            return; &#13;&#10;        }&#13;&#10;        Instance = this;&#13;&#10;    }&#13;&#10;&#13;&#10;    void Start()&#13;&#10;    {&#13;&#10;        // Buscar la cámara si no está asignada&#13;&#10;        if (thirdPersonCamera == null)&#13;&#10;        {&#13;&#10;            thirdPersonCamera = FindFirstObjectByType&lt;vThirdPersonCamera&gt;();&#13;&#10;        }&#13;&#10;        &#13;&#10;        if (thirdPersonCamera != null)&#13;&#10;        {&#13;&#10;            mainCamera = thirdPersonCamera.GetComponent&lt;Camera&gt;();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /// &lt;summary&gt;&#13;&#10;    /// Inicia el modo de cámara de diálogo mostrando al player de perfil mirando al NPC&#13;&#10;    /// &lt;/summary&gt;&#13;&#10;    public void StartDialogueCamera(Transform npcTransform)&#13;&#10;    {&#13;&#10;        if (!enableDialogueCamera || npcTransform == null || isInDialogueMode) return;&#13;&#10;&#13;&#10;        // Buscar el player&#13;&#10;        GameObject playerObj = GameObject.FindGameObjectWithTag(&quot;Player&quot;);&#13;&#10;        if (playerObj == null)&#13;&#10;        {&#13;&#10;            if (showDebugLogs)&#13;&#10;                Debug.LogWarning(&quot;[DialogueCameraController] No se encontró el player.&quot;);&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        player = playerObj.transform;&#13;&#10;        currentNPC = npcTransform;&#13;&#10;        isInDialogueMode = true;&#13;&#10;&#13;&#10;        // Buscar la cámara si aún no está asignada&#13;&#10;        if (thirdPersonCamera == null)&#13;&#10;        {&#13;&#10;            thirdPersonCamera = FindFirstObjectByType&lt;vThirdPersonCamera&gt;();&#13;&#10;        }&#13;&#10;&#13;&#10;        if (thirdPersonCamera == null)&#13;&#10;        {&#13;&#10;            if (showDebugLogs)&#13;&#10;                Debug.LogWarning(&quot;[DialogueCameraController] No se encontró vThirdPersonCamera.&quot;);&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        if (mainCamera == null)&#13;&#10;        {&#13;&#10;            mainCamera = thirdPersonCamera.GetComponent&lt;Camera&gt;();&#13;&#10;        }&#13;&#10;&#13;&#10;        // Guardar estado original&#13;&#10;        wasLocked = thirdPersonCamera.lockCamera;&#13;&#10;        if (mainCamera != null)&#13;&#10;        {&#13;&#10;            originalCameraLocalPosition = mainCamera.transform.localPosition;&#13;&#10;        }&#13;&#10;        originalPlayerRotation = player.rotation;&#13;&#10;        &#13;&#10;        // Bloquear la cámara para que el jugador no pueda moverla&#13;&#10;        thirdPersonCamera.lockCamera = true;&#13;&#10;&#13;&#10;        // Rotar el player hacia el NPC si está habilitado&#13;&#10;        if (rotatePlayerToNPC)&#13;&#10;        {&#13;&#10;            Vector3 directionToNPC = (currentNPC.position - player.position).normalized;&#13;&#10;            directionToNPC.y = 0; // Mantener rotación horizontal&#13;&#10;            if (directionToNPC != Vector3.zero)&#13;&#10;            {&#13;&#10;                player.rotation = Quaternion.LookRotation(directionToNPC);&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        if (showDebugLogs)&#13;&#10;            Debug.Log($&quot;[DialogueCameraController] Iniciando cámara de diálogo con {npcTransform.name}&quot;);&#13;&#10;&#13;&#10;        // Calcular y aplicar la posición de cámara lateral&#13;&#10;        CalculateDialogueCameraTransform();&#13;&#10;        &#13;&#10;        // Iniciar transición suave&#13;&#10;        if (transitionCoroutine != null)&#13;&#10;            StopCoroutine(transitionCoroutine);&#13;&#10;        transitionCoroutine = StartCoroutine(TransitionToDialogueCamera());&#13;&#10;    }&#13;&#10;&#13;&#10;    /// &lt;summary&gt;&#13;&#10;    /// Finaliza el modo de cámara de diálogo y vuelve al comportamiento normal&#13;&#10;    /// &lt;/summary&gt;&#13;&#10;    public void EndDialogueCamera()&#13;&#10;    {&#13;&#10;        if (!isInDialogueMode) return;&#13;&#10;&#13;&#10;        if (showDebugLogs)&#13;&#10;            Debug.Log(&quot;[DialogueCameraController] Finalizando cámara de diálogo&quot;);&#13;&#10;&#13;&#10;        if (thirdPersonCamera != null)&#13;&#10;        {&#13;&#10;            thirdPersonCamera.lockCamera = wasLocked;&#13;&#10;        }&#13;&#10;&#13;&#10;        // Restaurar posición local de la cámara&#13;&#10;        if (mainCamera != null &amp;&amp; transitionCoroutine != null)&#13;&#10;        {&#13;&#10;            StopCoroutine(transitionCoroutine);&#13;&#10;            transitionCoroutine = StartCoroutine(TransitionBackToNormal());&#13;&#10;        }&#13;&#10;        else&#13;&#10;        {&#13;&#10;            isInDialogueMode = false;&#13;&#10;            currentNPC = null;&#13;&#10;            player = null;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void CalculateDialogueCameraTransform()&#13;&#10;    {&#13;&#10;        if (player == null || currentNPC == null) return;&#13;&#10;&#13;&#10;        // Dirección del player al NPC (en el plano horizontal)&#13;&#10;        Vector3 directionToNPC = (currentNPC.position - player.position);&#13;&#10;        directionToNPC.y = 0;&#13;&#10;        directionToNPC.Normalize();&#13;&#10;&#13;&#10;        // Perpendicular a la derecha para posicionar la cámara lateral&#13;&#10;        Vector3 rightDirection = Vector3.Cross(Vector3.up, directionToNPC).normalized;&#13;&#10;&#13;&#10;        // Posición de la cámara: a un lado del player, un poco atrás y elevada&#13;&#10;        Vector3 sidePosition = player.position + rightDirection * sideDistance;&#13;&#10;        Vector3 backOffset = -directionToNPC * backDistance;&#13;&#10;        Vector3 heightPosition = Vector3.up * (player.position.y + heightOffset + 1.5f);&#13;&#10;&#13;&#10;        targetCameraPosition = sidePosition + backOffset;&#13;&#10;        targetCameraPosition.y = heightPosition.y;&#13;&#10;&#13;&#10;        // La cámara mira hacia el punto medio entre el player y el NPC&#13;&#10;        Vector3 lookAtPoint = (player.position + currentNPC.position) / 2f;&#13;&#10;        lookAtPoint.y += 1.5f; // A la altura de las caras&#13;&#10;&#13;&#10;        targetCameraRotation = Quaternion.LookRotation(lookAtPoint - targetCameraPosition);&#13;&#10;&#13;&#10;        if (showDebugLogs)&#13;&#10;        {&#13;&#10;            Debug.DrawLine(player.position, currentNPC.position, Color.yellow, 2f);&#13;&#10;            Debug.DrawLine(targetCameraPosition, lookAtPoint, Color.cyan, 2f);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private IEnumerator TransitionToDialogueCamera()&#13;&#10;    {&#13;&#10;        if (mainCamera == null) yield break;&#13;&#10;&#13;&#10;        Vector3 startPos = mainCamera.transform.position;&#13;&#10;        Quaternion startRot = mainCamera.transform.rotation;&#13;&#10;&#13;&#10;        float elapsed = 0f;&#13;&#10;        float duration = 1f / transitionSpeed;&#13;&#10;&#13;&#10;        while (elapsed &lt; duration &amp;&amp; isInDialogueMode)&#13;&#10;        {&#13;&#10;            elapsed += Time.deltaTime;&#13;&#10;            float t = Mathf.SmoothStep(0f, 1f, elapsed / duration);&#13;&#10;&#13;&#10;            mainCamera.transform.position = Vector3.Lerp(startPos, targetCameraPosition, t);&#13;&#10;            mainCamera.transform.rotation = Quaternion.Slerp(startRot, targetCameraRotation, t);&#13;&#10;&#13;&#10;            yield return null;&#13;&#10;        }&#13;&#10;&#13;&#10;        if (isInDialogueMode)&#13;&#10;        {&#13;&#10;            mainCamera.transform.position = targetCameraPosition;&#13;&#10;            mainCamera.transform.rotation = targetCameraRotation;&#13;&#10;        }&#13;&#10;&#13;&#10;        transitionCoroutine = null;&#13;&#10;    }&#13;&#10;&#13;&#10;    private IEnumerator TransitionBackToNormal()&#13;&#10;    {&#13;&#10;        if (mainCamera == null)&#13;&#10;        {&#13;&#10;            isInDialogueMode = false;&#13;&#10;            currentNPC = null;&#13;&#10;            player = null;&#13;&#10;            yield break;&#13;&#10;        }&#13;&#10;&#13;&#10;        Vector3 startPos = mainCamera.transform.position;&#13;&#10;        Quaternion startRot = mainCamera.transform.rotation;&#13;&#10;&#13;&#10;        // Calcular posición de retorno basada en la posición original del player&#13;&#10;        Vector3 targetPos = player.position - player.forward * 3f + Vector3.up * 2f;&#13;&#10;        Quaternion targetRot = Quaternion.LookRotation(player.position - targetPos);&#13;&#10;&#13;&#10;        float elapsed = 0f;&#13;&#10;        float duration = 0.8f / transitionSpeed;&#13;&#10;&#13;&#10;        while (elapsed &lt; duration)&#13;&#10;        {&#13;&#10;            elapsed += Time.deltaTime;&#13;&#10;            float t = Mathf.SmoothStep(0f, 1f, elapsed / duration);&#13;&#10;&#13;&#10;            mainCamera.transform.position = Vector3.Lerp(startPos, targetPos, t);&#13;&#10;            mainCamera.transform.rotation = Quaternion.Slerp(startRot, targetRot, t);&#13;&#10;&#13;&#10;            yield return null;&#13;&#10;        }&#13;&#10;&#13;&#10;        isInDialogueMode = false;&#13;&#10;        currentNPC = null;&#13;&#10;        player = null;&#13;&#10;        transitionCoroutine = null;&#13;&#10;    }&#13;&#10;&#13;&#10;    void LateUpdate()&#13;&#10;    {&#13;&#10;        // Mantener la cámara en posición de diálogo mientras esté activa&#13;&#10;        if (isInDialogueMode &amp;&amp; currentNPC != null &amp;&amp; player != null &amp;&amp; mainCamera != null &amp;&amp; transitionCoroutine == null)&#13;&#10;        {&#13;&#10;            // Recalcular por si el player o NPC se movieron&#13;&#10;            CalculateDialogueCameraTransform();&#13;&#10;            &#13;&#10;            // Aplicar con suavizado ligero para compensar movimientos pequeños&#13;&#10;            mainCamera.transform.position = Vector3.Lerp(mainCamera.transform.position, targetCameraPosition, Time.deltaTime * 5f);&#13;&#10;            mainCamera.transform.rotation = Quaternion.Slerp(mainCamera.transform.rotation, targetCameraRotation, Time.deltaTime * 5f);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    void OnDrawGizmosSelected()&#13;&#10;    {&#13;&#10;        if (isInDialogueMode &amp;&amp; currentNPC != null &amp;&amp; player != null)&#13;&#10;        {&#13;&#10;            // Visualizar la configuración de la cámara&#13;&#10;            Gizmos.color = Color.yellow;&#13;&#10;            Gizmos.DrawLine(player.position + Vector3.up, currentNPC.position + Vector3.up);&#13;&#10;            &#13;&#10;            Gizmos.color = Color.cyan;&#13;&#10;            Gizmos.DrawWireSphere(targetCameraPosition, 0.3f);&#13;&#10;            Gizmos.DrawLine(targetCameraPosition, (player.position + currentNPC.position) / 2f + Vector3.up * 1.5f);&#13;&#10;            &#13;&#10;            Gizmos.color = Color.green;&#13;&#10;            Gizmos.DrawWireSphere(player.position + Vector3.up * 1.5f, 0.2f);&#13;&#10;            &#13;&#10;            Gizmos.color = Color.red;&#13;&#10;            Gizmos.DrawWireSphere(currentNPC.position + Vector3.up * 1.5f, 0.2f);&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Interaction/InteractionDetector.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Interaction/InteractionDetector.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;&#10;[DisallowMultipleComponent]&#10;public class InteractionDetector : MonoBehaviour&#10;{&#10;    [Header(&quot;Detección&quot;)]&#10;    [SerializeField] private float range = 2.2f;&#10;    [SerializeField] private float focusRadius = 0.35f;&#10;    [SerializeField] private LayerMask interactableMask;&#10;    [Tooltip(&quot;Opcional: origen/dirección para el ray (p.ej. pivot de cámara). Si está vacío usa el transform del Player.&quot;)]&#10;    [SerializeField] private Transform aimSource;&#10;&#10;    [Header(&quot;Input (Gamepad)&quot;)]&#10;    [Tooltip(&quot;Acción GamePlay/Interact (mismo botón que Jump: A). Se habilita solo al enfocar.&quot;)]&#10;    [SerializeField] private InputActionReference interactAction;&#10;    [Tooltip(&quot;Acción GamePlay/Jump (A). Se deshabilita al enfocar para que no salte.&quot;)]&#10;    [SerializeField] private InputActionReference jumpAction;&#10;    [SerializeField] private bool disableJumpWhenFocused = true;&#10;&#10;    private Interactable current;&#10;    private PlayerCarrySystem _carrySystem;&#10;    private bool _isChaining = false; // Flag para evitar parpadeo del hint durante encadenamiento&#10;&#10;    private void Awake()&#10;    {&#10;        _carrySystem = GetComponent&lt;PlayerCarrySystem&gt;();&#10;    }&#10;&#10;    private void OnEnable()&#10;    {&#10;        // Escuchamos Interact, pero la tendremos deshabilitada por defecto.&#10;        if (interactAction?.action != null)&#10;        {&#10;            interactAction.action.performed += OnInteract;&#10;            if (interactAction.action.enabled) interactAction.action.Disable();&#10;        }&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        if (interactAction?.action != null)&#10;        {&#10;            interactAction.action.performed -= OnInteract;&#10;            // Deja Interact deshabilitada al salir&#10;            if (interactAction.action.enabled) interactAction.action.Disable();&#10;        }&#10;        // Asegura que Jump vuelve habilitada&#10;        if (disableJumpWhenFocused &amp;&amp; jumpAction?.action != null &amp;&amp; !jumpAction.action.enabled)&#10;            jumpAction.action.Enable();&#10;    }&#10;&#10;    private void Update()&#10;    {&#10;        // Si hay diálogo abierto O está en encadenamiento, no enfocamos nada nuevo&#10;        bool dialogueActive = (DialogueManager.Instance != null &amp;&amp; DialogueManager.Instance.IsOpen) || _isChaining;&#10;        if (dialogueActive)&#10;        {&#10;            // Durante encadenamiento, mantener el hint actual visible si existe&#10;            if (!_isChaining)&#10;                SetCurrent(null);&#10;            return;&#10;        }&#10;&#10;        // Si está cargando algo, mantener el botón A habilitado para soltar&#10;        if (_carrySystem != null &amp;&amp; _carrySystem.IsCarrying)&#10;        {&#10;            SetCurrent(null); // No detectar otros objetos mientras carga&#10;            EnableInteractAction(true); // Pero mantener el botón A activo para soltar&#10;            return;&#10;        }&#10;&#10;        var nearest = FindNearest();&#10;        SetCurrent(nearest);&#10;    }&#10;&#10;    private void OnInteract(InputAction.CallbackContext _)&#10;    {&#10;        // Si está cargando algo, soltar&#10;        if (_carrySystem != null &amp;&amp; _carrySystem.IsCarrying)&#10;        {&#10;            _carrySystem.DropObject();&#10;            return;&#10;        }&#10;&#10;        // Si no está cargando, intentar interactuar con objeto enfocado&#10;        if (current != null &amp;&amp; current.CanInteract(gameObject))&#10;            current.Interact(gameObject);&#10;    }&#10;&#10;    private void SetCurrent(Interactable next)&#10;    {&#10;        if (current == next) return;&#10;&#10;        if (current) current.SetHintVisible(false);&#10;        current = next;&#10;        if (current) current.SetHintVisible(true);&#10;&#10;        EnableInteractAction(current != null);&#10;&#10;        // Deshabilita Jump mientras hay foco (para que A no salte)&#10;        if (disableJumpWhenFocused &amp;&amp; jumpAction?.action != null)&#10;        {&#10;            if (current &amp;&amp; jumpAction.action.enabled) &#10;                jumpAction.action.Disable();&#10;            else if (!current &amp;&amp; !jumpAction.action.enabled &amp;&amp; !(DialogueManager.Instance != null &amp;&amp; DialogueManager.Instance.IsOpen)) &#10;                jumpAction.action.Enable();&#10;        }&#10;    }&#10;&#10;    private void EnableInteractAction(bool enable)&#10;    {&#10;        var ia = interactAction?.action;&#10;        if (ia != null)&#10;        {&#10;            if (enable &amp;&amp; !ia.enabled) ia.Enable();&#10;            else if (!enable &amp;&amp; ia.enabled) ia.Disable();&#10;        }&#10;    }&#10;&#10;    private Interactable FindNearest()&#10;    {&#10;        var t = aimSource ? aimSource : transform;&#10;        Vector3 origin = t.position + Vector3.up * 1.1f;&#10;&#10;        var cols = Physics.OverlapSphere(origin, range, interactableMask, QueryTriggerInteraction.Collide);&#10;        if (cols == null || cols.Length == 0) return null;&#10;&#10;        float best = float.MaxValue;&#10;        Interactable winner = null;&#10;&#10;        foreach (var c in cols)&#10;        {&#10;            var it = c.GetComponentInParent&lt;Interactable&gt;();&#10;            if (!it || !it.CanInteract(gameObject)) continue;&#10;&#10;            float d = Vector3.Distance(origin, it.transform.position);&#10;            if (d &lt; best)&#10;            {&#10;                Vector3 dir = (it.transform.position - origin).normalized;&#10;                if (Physics.SphereCast(origin, focusRadius, dir, out _, d + 0.1f, ~0, QueryTriggerInteraction.Ignore))&#10;                {&#10;                    best = d;&#10;                    winner = it;&#10;                }&#10;            }&#10;        }&#10;        return winner;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Permite notificar que se está produciendo un encadenamiento de diálogos&#10;    /// para evitar que el hint parpadee entre diálogos consecutivos&#10;    /// &lt;/summary&gt;&#10;    public void SetChaining(bool isChaining)&#10;    {&#10;        _isChaining = isChaining;&#10;    }&#10;&#10;#if UNITY_EDITOR&#10;    private void OnDrawGizmosSelected()&#10;    {&#10;        var t = aimSource ? aimSource : transform;&#10;        Gizmos.color = new Color(0,1,1,0.35f);&#10;        Gizmos.DrawWireSphere(t.position + Vector3.up * 1.1f, range);&#10;    }&#10;#endif&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#13;&#10;using UnityEngine.InputSystem;&#13;&#10;&#13;&#10;[DisallowMultipleComponent]&#13;&#10;public class InteractionDetector : MonoBehaviour&#13;&#10;{&#13;&#10;    [Header(&quot;Detección&quot;)]&#13;&#10;    [SerializeField] private float range = 2.2f;&#13;&#10;    [SerializeField] private float focusRadius = 0.35f;&#13;&#10;    [SerializeField] private LayerMask interactableMask;&#13;&#10;    [Tooltip(&quot;Opcional: origen/dirección para el ray (p.ej. pivot de cámara). Si está vacío usa el transform del Player.&quot;)]&#13;&#10;    [SerializeField] private Transform aimSource;&#13;&#10;&#13;&#10;    [Header(&quot;Input (Gamepad)&quot;)]&#13;&#10;    [Tooltip(&quot;Acción GamePlay/Interact (mismo botón que Jump: A). Se habilita solo al enfocar.&quot;)]&#13;&#10;    [SerializeField] private InputActionReference interactAction;&#13;&#10;    [Tooltip(&quot;Acción GamePlay/Jump (A). Se deshabilita al enfocar para que no salte.&quot;)]&#13;&#10;    [SerializeField] private InputActionReference jumpAction;&#13;&#10;    [SerializeField] private bool disableJumpWhenFocused = true;&#13;&#10;&#13;&#10;    private Interactable current;&#13;&#10;    private PlayerCarrySystem _carrySystem;&#13;&#10;&#13;&#10;    private void Awake()&#13;&#10;    {&#13;&#10;        _carrySystem = GetComponent&lt;PlayerCarrySystem&gt;();&#13;&#10;    }&#13;&#10;&#13;&#10;    private void OnEnable()&#13;&#10;    {&#13;&#10;        // Escuchamos Interact, pero la tendremos deshabilitada por defecto.&#13;&#10;        if (interactAction?.action != null)&#13;&#10;        {&#13;&#10;            interactAction.action.performed += OnInteract;&#13;&#10;            if (interactAction.action.enabled) interactAction.action.Disable();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void OnDisable()&#13;&#10;    {&#13;&#10;        if (interactAction?.action != null)&#13;&#10;        {&#13;&#10;            interactAction.action.performed -= OnInteract;&#13;&#10;            // Deja Interact deshabilitada al salir&#13;&#10;            if (interactAction.action.enabled) interactAction.action.Disable();&#13;&#10;        }&#13;&#10;        // Asegura que Jump vuelve habilitada&#13;&#10;        if (disableJumpWhenFocused &amp;&amp; jumpAction?.action != null &amp;&amp; !jumpAction.action.enabled)&#13;&#10;            jumpAction.action.Enable();&#13;&#10;    }&#13;&#10;&#13;&#10;    private void Update()&#13;&#10;    {&#13;&#10;        // Si hay diálogo abierto, no enfocamos nada nuevo&#13;&#10;        bool dialogueActive = DialogueManager.Instance != null &amp;&amp; DialogueManager.Instance.IsOpen;&#13;&#10;        if (dialogueActive)&#13;&#10;        {&#13;&#10;            SetCurrent(null);&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        // Si está cargando algo, mantener el botón A habilitado para soltar&#13;&#10;        if (_carrySystem != null &amp;&amp; _carrySystem.IsCarrying)&#13;&#10;        {&#13;&#10;            SetCurrent(null); // No detectar otros objetos mientras carga&#13;&#10;            EnableInteractAction(true); // Pero mantener el botón A activo para soltar&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        var nearest = FindNearest();&#13;&#10;        SetCurrent(nearest);&#13;&#10;    }&#13;&#10;&#13;&#10;    private void OnInteract(InputAction.CallbackContext _)&#13;&#10;    {&#13;&#10;        // Si está cargando algo, soltar&#13;&#10;        if (_carrySystem != null &amp;&amp; _carrySystem.IsCarrying)&#13;&#10;        {&#13;&#10;            _carrySystem.DropObject();&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        // Si no está cargando, intentar interactuar con objeto enfocado&#13;&#10;        if (current != null &amp;&amp; current.CanInteract(gameObject))&#13;&#10;            current.Interact(gameObject);&#13;&#10;    }&#13;&#10;&#13;&#10;    private void SetCurrent(Interactable next)&#13;&#10;    {&#13;&#10;        if (current == next) return;&#13;&#10;&#13;&#10;        if (current) current.SetHintVisible(false);&#13;&#10;        current = next;&#13;&#10;        if (current) current.SetHintVisible(true);&#13;&#10;&#13;&#10;        EnableInteractAction(current != null);&#13;&#10;&#13;&#10;        // Deshabilita Jump mientras hay foco (para que A no salte)&#13;&#10;        if (disableJumpWhenFocused &amp;&amp; jumpAction?.action != null)&#13;&#10;        {&#13;&#10;            if (current &amp;&amp; jumpAction.action.enabled) &#13;&#10;                jumpAction.action.Disable();&#13;&#10;            else if (!current &amp;&amp; !jumpAction.action.enabled &amp;&amp; !(DialogueManager.Instance != null &amp;&amp; DialogueManager.Instance.IsOpen)) &#13;&#10;                jumpAction.action.Enable();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void EnableInteractAction(bool enable)&#13;&#10;    {&#13;&#10;        var ia = interactAction?.action;&#13;&#10;        if (ia != null)&#13;&#10;        {&#13;&#10;            if (enable &amp;&amp; !ia.enabled) ia.Enable();&#13;&#10;            else if (!enable &amp;&amp; ia.enabled) ia.Disable();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private Interactable FindNearest()&#13;&#10;    {&#13;&#10;        var t = aimSource ? aimSource : transform;&#13;&#10;        Vector3 origin = t.position + Vector3.up * 1.1f;&#13;&#10;&#13;&#10;        var cols = Physics.OverlapSphere(origin, range, interactableMask, QueryTriggerInteraction.Collide);&#13;&#10;        if (cols == null || cols.Length == 0) return null;&#13;&#10;&#13;&#10;        float best = float.MaxValue;&#13;&#10;        Interactable winner = null;&#13;&#10;&#13;&#10;        foreach (var c in cols)&#13;&#10;        {&#13;&#10;            var it = c.GetComponentInParent&lt;Interactable&gt;();&#13;&#10;            if (!it || !it.CanInteract(gameObject)) continue;&#13;&#10;&#13;&#10;            float d = Vector3.Distance(origin, it.transform.position);&#13;&#10;            if (d &lt; best)&#13;&#10;            {&#13;&#10;                Vector3 dir = (it.transform.position - origin).normalized;&#13;&#10;                if (Physics.SphereCast(origin, focusRadius, dir, out _, d + 0.1f, ~0, QueryTriggerInteraction.Ignore))&#13;&#10;                {&#13;&#10;                    best = d;&#13;&#10;                    winner = it;&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;        return winner;&#13;&#10;    }&#13;&#10;&#13;&#10;#if UNITY_EDITOR&#13;&#10;    private void OnDrawGizmosSelected()&#13;&#10;    {&#13;&#10;        var t = aimSource ? aimSource : transform;&#13;&#10;        Gizmos.color = new Color(0,1,1,0.35f);&#13;&#10;        Gizmos.DrawWireSphere(t.position + Vector3.up * 1.1f, range);&#13;&#10;    }&#13;&#10;#endif&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>