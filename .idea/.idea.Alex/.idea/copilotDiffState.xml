<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/SceneTransitionLoader.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/SceneTransitionLoader.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using EasyTransition;&#10;using System.Collections;&#10;using UnityEngine.Events;&#10;&#10;[DisallowMultipleComponent]&#10;public class SceneTransitionLoader : MonoBehaviour&#10;{&#10;    private static SceneTransitionLoader _inst;&#10;    public static SceneTransitionLoader Instance =&gt; _inst;&#10;&#10;    [Header(&quot;Valores por defecto&quot;)]&#10;    public TransitionSettings defaultSettings;     // ← asigna tu Fade.asset aquí&#10;    [Min(0)] public float defaultDelay = 0f;&#10;    [Min(0)] public float waitForManagerSec = 0.5f;&#10;&#10;    // Evita arranques concurrentes&#10;    private bool _isLoading = false;&#10;&#10;    void Awake()&#10;    {&#10;        if (_inst == null)&#10;        {&#10;            _inst = this;&#10;            DontDestroyOnLoad(gameObject);&#10;            return;&#10;        }&#10;        if (_inst != this)&#10;        {&#10;            // Prefiere la instancia que tenga defaultSettings asignado&#10;            bool prevOk = _inst.defaultSettings != null;&#10;            bool thisOk = this.defaultSettings != null;&#10;            if (!prevOk &amp;&amp; thisOk)&#10;            {&#10;                Destroy(_inst.gameObject);&#10;                _inst = this;&#10;                DontDestroyOnLoad(gameObject);&#10;            }&#10;            else Destroy(gameObject);&#10;        }&#10;    }&#10;&#10;    // APIs públicas&#10;    public static void Load(string sceneName)&#10;    {&#10;        if (_inst)&#10;        {&#10;            if (_inst._isLoading)&#10;            {&#10;                Debug.LogWarning(&quot;SceneTransitionLoader: Load already in progress; ignoring request.&quot;);&#10;                return;&#10;            }&#10;            _inst.StartCoroutine(_inst.LoadRoutine(sceneName, _inst.defaultSettings, _inst.defaultDelay));&#10;        }&#10;        else SceneManager.LoadScene(sceneName);&#10;    }&#10;&#10;    public static void Load(string sceneName, TransitionSettings settings, float delay = 0f)&#10;    {&#10;        if (_inst)&#10;        {&#10;            if (_inst._isLoading)&#10;            {&#10;                Debug.LogWarning(&quot;SceneTransitionLoader: Load already in progress; ignoring request.&quot;);&#10;                return;&#10;            }&#10;            _inst.StartCoroutine(_inst.LoadRoutine(sceneName, settings ?? _inst.defaultSettings, delay));&#10;        }&#10;        else SceneManager.LoadScene(sceneName);&#10;    }&#10;&#10;    // Núcleo: transición SIN cambio de escena + carga en el &quot;cut&quot;&#10;    IEnumerator LoadRoutine(string sceneName, TransitionSettings settings, float delay)&#10;    {&#10;        // marcamos que estamos en proceso&#10;        _isLoading = true;&#10;        TransitionManager tm = null;&#10;        UnityAction onCut = null;&#10;        UnityAction onEnd = null;&#10;&#10;        try&#10;        {&#10;            // Si seguimos sin settings, no llames al plugin (evita su error)&#10;            if (settings == null)&#10;            {&#10;                SceneManager.LoadScene(sceneName);&#10;                yield break;&#10;            }&#10;&#10;            // Espera a que exista el TransitionManager (Start entra aditivo)&#10;            float t = 0f;&#10;            while (t &lt; waitForManagerSec &amp;&amp; (tm = FindTM()) == null)&#10;            {&#10;                yield return null;&#10;                t += Time.unscaledDeltaTime;&#10;            }&#10;            if (tm == null) tm = FindTM();&#10;&#10;            if (tm == null)&#10;            {&#10;                SceneManager.LoadScene(sceneName); // fallback seguro&#10;                yield break;&#10;            }&#10;&#10;            // Si los settings no contienen prefabs válidos, intentar usar defaultSettings o hacer fallback&#10;            if (settings != null &amp;&amp; !(settings.transitionIn != null || settings.transitionOut != null))&#10;            {&#10;                if (this.defaultSettings != null &amp;&amp; (this.defaultSettings.transitionIn != null || this.defaultSettings.transitionOut != null))&#10;                {&#10;                    settings = this.defaultSettings;&#10;                }&#10;                else&#10;                {&#10;                    // No hay transición válida disponible: carga directa y salimos&#10;                    SceneManager.LoadScene(sceneName);&#10;                    yield break;&#10;                }&#10;            }&#10;&#10;            // Evitar llamar a tm.Transition si el TransitionManager ya está en medio de otra transición.&#10;            bool isRunning = false;&#10;            try&#10;            {&#10;                var fi = typeof(TransitionManager).GetField(&quot;runningTransition&quot;, System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);&#10;                if (fi != null)&#10;                    isRunning = (bool)fi.GetValue(tm);&#10;            }&#10;            catch { isRunning = false; }&#10;&#10;            if (isRunning)&#10;            {&#10;                // Espera hasta un timeout razonable a que termine la transición actual&#10;                float waitTimeout = 3f; // aumentar timeout para reducir false fallbacks&#10;                float waited = 0f;&#10;                while (waited &lt; waitTimeout)&#10;                {&#10;                    yield return null;&#10;                    waited += Time.unscaledDeltaTime;&#10;                    try&#10;                    {&#10;                        var fi = typeof(TransitionManager).GetField(&quot;runningTransition&quot;, System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);&#10;                        if (fi == null) { isRunning = false; break; }&#10;                        isRunning = (bool)fi.GetValue(tm);&#10;                        if (!isRunning) break;&#10;                    }&#10;                    catch { isRunning = false; break; }&#10;                }&#10;&#10;                if (isRunning)&#10;                {&#10;                    // Tras timeout, evitamos bloquear la experiencia: cargar sin transición&#10;                    Debug.LogWarning(&quot;SceneTransitionLoader: TransitionManager busy; loading scene without transition to avoid conflict.&quot;);&#10;                    SceneManager.LoadScene(sceneName);&#10;                    yield break;&#10;                }&#10;            }&#10;&#10;            // Ahora que el manager está libre, suscribimos los handlers locales y lanzamos la transición.&#10;            onCut = () =&gt;&#10;            {&#10;                // Momento negro: cambiamos la escena&#10;                SceneManager.LoadScene(sceneName);&#10;                if (tm != null) tm.onTransitionCutPointReached -= onCut;&#10;            };&#10;&#10;            onEnd = () =&gt;&#10;            {&#10;                if (tm != null) tm.onTransitionEnd -= onEnd;&#10;                // aquí podrías volver a habilitar input si lo desactivaste al empezar&#10;            };&#10;&#10;            tm.onTransitionCutPointReached += onCut;&#10;            tm.onTransitionEnd            += onEnd;&#10;&#10;            try&#10;            {&#10;                tm.Transition(settings, delay);&#10;            }&#10;            catch&#10;            {&#10;                // Si por alguna razón la llamada a Transition falla, hacemos fallback seguro&#10;                Debug.LogWarning(&quot;SceneTransitionLoader: Transition failed; loading scene directly.&quot;);&#10;                // nos aseguramos de desuscribir handlers que pudimos haber añadido&#10;                try&#10;                {&#10;                    if (tm != null)&#10;                    {&#10;                        if (onCut != null) tm.onTransitionCutPointReached -= onCut;&#10;                        if (onEnd != null) tm.onTransitionEnd -= onEnd;&#10;                    }&#10;                }&#10;                catch { }&#10;                SceneManager.LoadScene(sceneName);&#10;                yield break;&#10;            }&#10;        }&#10;        finally&#10;        {&#10;            // limpieza segura: desuscribimos por si queda alguno (es seguro hacer -= si no está suscrito)&#10;            try&#10;            {&#10;                if (tm != null)&#10;                {&#10;                    if (onCut != null) tm.onTransitionCutPointReached -= onCut;&#10;                    if (onEnd != null) tm.onTransitionEnd -= onEnd;&#10;                }&#10;            }&#10;            catch { }&#10;            _isLoading = false;&#10;        }&#10;    }&#10;&#10;    static TransitionManager FindTM()&#10;    {&#10;    #if UNITY_2022_3_OR_NEWER&#10;        return Object.FindFirstObjectByType&lt;TransitionManager&gt;(FindObjectsInactive.Include);&#10;    #else&#10;        return Object.FindObjectOfType&lt;TransitionManager&gt;(true);&#10;    #endif&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using EasyTransition;&#10;using System.Collections;&#10;using UnityEngine.Events;&#10;&#10;[DisallowMultipleComponent]&#10;public class SceneTransitionLoader : MonoBehaviour&#10;{&#10;    private static SceneTransitionLoader _inst;&#10;    public static SceneTransitionLoader Instance =&gt; _inst;&#10;&#10;    [Header(&quot;Valores por defecto&quot;)]&#10;    public TransitionSettings defaultSettings;     // ← asigna tu Fade.asset aquí&#10;    [Min(0)] public float defaultDelay = 0f;&#10;    [Min(0)] public float waitForManagerSec = 0.5f;&#10;&#10;    // Evita arranques concurrentes&#10;    private bool _isLoading = false;&#10;&#10;    void Awake()&#10;    {&#10;        if (_inst == null)&#10;        {&#10;            _inst = this;&#10;            DontDestroyOnLoad(gameObject);&#10;            return;&#10;        }&#10;        if (_inst != this)&#10;        {&#10;            // Prefiere la instancia que tenga defaultSettings asignado&#10;            bool prevOk = _inst.defaultSettings != null;&#10;            bool thisOk = this.defaultSettings != null;&#10;            if (!prevOk &amp;&amp; thisOk)&#10;            {&#10;                Destroy(_inst.gameObject);&#10;                _inst = this;&#10;                DontDestroyOnLoad(gameObject);&#10;            }&#10;            else Destroy(gameObject);&#10;        }&#10;    }&#10;&#10;    // APIs públicas&#10;    public static void Load(string sceneName)&#10;    {&#10;        if (_inst)&#10;        {&#10;            Debug.Log($&quot;SceneTransitionLoader.Load requested: {sceneName}&quot;);&#10;            if (_inst._isLoading)&#10;            {&#10;                Debug.LogWarning(&quot;SceneTransitionLoader: Load already in progress; ignoring request.&quot;);&#10;                return;&#10;            }&#10;            // marcamos inmediatamente para evitar reentradas mientras la coroutine no haya comenzado aún&#10;            _inst._isLoading = true;&#10;            _inst.StartCoroutine(_inst.LoadRoutine(sceneName, _inst.defaultSettings, _inst.defaultDelay));&#10;        }&#10;        else&#10;        {&#10;            Debug.Log(&quot;SceneTransitionLoader: No instance found, loading scene directly.&quot;);&#10;            SceneManager.LoadScene(sceneName);&#10;        }&#10;    }&#10;&#10;    public static void Load(string sceneName, TransitionSettings settings, float delay = 0f)&#10;    {&#10;        if (_inst)&#10;        {&#10;            Debug.Log($&quot;SceneTransitionLoader.Load requested (with settings): {sceneName}&quot;);&#10;            if (_inst._isLoading)&#10;            {&#10;                Debug.LogWarning(&quot;SceneTransitionLoader: Load already in progress; ignoring request.&quot;);&#10;                return;&#10;            }&#10;            // marcamos inmediatamente para evitar reentradas mientras la coroutine no haya comenzado aún&#10;            _inst._isLoading = true;&#10;            _inst.StartCoroutine(_inst.LoadRoutine(sceneName, settings ?? _inst.defaultSettings, delay));&#10;        }&#10;        else&#10;        {&#10;            Debug.Log(&quot;SceneTransitionLoader: No instance found, loading scene directly (settings provided).&quot;);&#10;            SceneManager.LoadScene(sceneName);&#10;        }&#10;    }&#10;&#10;    // Núcleo: transición SIN cambio de escena + carga en el &quot;cut&quot;&#10;    IEnumerator LoadRoutine(string sceneName, TransitionSettings settings, float delay)&#10;    {&#10;        Debug.Log($&quot;SceneTransitionLoader.LoadRoutine start for {sceneName}&quot;);&#10;        // marcamos que estamos en proceso&#10;        _isLoading = true;&#10;        TransitionManager tm = null;&#10;        UnityAction onCut = null;&#10;        UnityAction onEnd = null;&#10;&#10;        try&#10;        {&#10;            // Si seguimos sin settings, no llames al plugin (evita su error)&#10;            if (settings == null)&#10;            {&#10;                Debug.LogWarning($&quot;SceneTransitionLoader: No TransitionSettings provided for {sceneName}, loading directly.&quot;);&#10;                SceneManager.LoadScene(sceneName);&#10;                yield break;&#10;            }&#10;&#10;            // Espera a que exista el TransitionManager (Start entra aditivo)&#10;            float t = 0f;&#10;            while (t &lt; waitForManagerSec &amp;&amp; (tm = FindTM()) == null)&#10;            {&#10;                yield return null;&#10;                t += Time.unscaledDeltaTime;&#10;            }&#10;            if (tm == null) tm = FindTM();&#10;&#10;            if (tm == null)&#10;            {&#10;                Debug.LogWarning($&quot;SceneTransitionLoader: TransitionManager not found for {sceneName}, loading directly.&quot;);&#10;                SceneManager.LoadScene(sceneName); // fallback seguro&#10;                yield break;&#10;            }&#10;&#10;            // Si los settings no contienen prefabs válidos, intentar usar defaultSettings o hacer fallback&#10;            if (settings != null &amp;&amp; !(settings.transitionIn != null || settings.transitionOut != null))&#10;            {&#10;                if (this.defaultSettings != null &amp;&amp; (this.defaultSettings.transitionIn != null || this.defaultSettings.transitionOut != null))&#10;                {&#10;                    settings = this.defaultSettings;&#10;                    Debug.LogWarning($&quot;SceneTransitionLoader: Provided settings invalid for {sceneName}, using defaultSettings.&quot;);&#10;                }&#10;                else&#10;                {&#10;                    // No hay transición válida disponible: carga directa y salimos&#10;                    Debug.LogWarning($&quot;SceneTransitionLoader: No valid transition prefabs found for {sceneName}, loading directly.&quot;);&#10;                    SceneManager.LoadScene(sceneName);&#10;                    yield break;&#10;                }&#10;            }&#10;&#10;            // Evitar llamar a tm.Transition si el TransitionManager ya está en medio de otra transición.&#10;            bool isRunning = false;&#10;            try&#10;            {&#10;                var fi = typeof(TransitionManager).GetField(&quot;runningTransition&quot;, System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);&#10;                if (fi != null)&#10;                    isRunning = (bool)fi.GetValue(tm);&#10;            }&#10;            catch (System.Exception ex) { Debug.LogException(ex); isRunning = false; }&#10;&#10;            if (isRunning)&#10;            {&#10;                // Espera hasta un timeout razonable a que termine la transición actual&#10;                float waitTimeout = 3f; // aumentar timeout para reducir false fallbacks&#10;                float waited = 0f;&#10;                while (waited &lt; waitTimeout)&#10;                {&#10;                    yield return null;&#10;                    waited += Time.unscaledDeltaTime;&#10;                    try&#10;                    {&#10;                        var fi = typeof(TransitionManager).GetField(&quot;runningTransition&quot;, System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);&#10;                        if (fi == null) { isRunning = false; break; }&#10;                        isRunning = (bool)fi.GetValue(tm);&#10;                        if (!isRunning) break;&#10;                    }&#10;                    catch (System.Exception ex) { Debug.LogException(ex); isRunning = false; break; }&#10;                }&#10;&#10;                if (isRunning)&#10;                {&#10;                    // Tras timeout, evitamos bloquear la experiencia: cargar sin transición&#10;                    Debug.LogWarning($&quot;SceneTransitionLoader: TransitionManager busy; loading scene {sceneName} without transition to avoid conflict.&quot;);&#10;                    SceneManager.LoadScene(sceneName);&#10;                    yield break;&#10;                }&#10;            }&#10;&#10;            // Ahora que el manager está libre, suscribimos los handlers locales y lanzamos la transición.&#10;            // Preparar control de finalización y carga única de escena&#10;            bool completed = false;&#10;            bool sceneLoaded = false;&#10;&#10;            // Redefinimos los handlers para usar las banderas locales de control&#10;            onCut = () =&gt;&#10;            {&#10;                Debug.Log($&quot;SceneTransitionLoader: onCut invoked for {sceneName}&quot;);&#10;                // Dejar que el TransitionManager haga la carga de escena en su Timer(string,...)&#10;                sceneLoaded = true; // marcar para evitar fallback manual&#10;                Debug.Log($&quot;SceneTransitionLoader: onCut - plugin will load the scene: {sceneName}&quot;);&#10;                completed = true;&#10;&#10;                try { if (tm != null) tm.onTransitionCutPointReached -= onCut; } catch (System.Exception ex) { Debug.LogException(ex); }&#10;            };&#10;&#10;            onEnd = () =&gt;&#10;            {&#10;                Debug.Log($&quot;SceneTransitionLoader: onEnd invoked for {sceneName}&quot;);&#10;                completed = true;&#10;                try { if (tm != null) tm.onTransitionEnd -= onEnd; } catch (System.Exception ex) { Debug.LogException(ex); }&#10;            };&#10;&#10;            // Suscribimos una vez con las implementaciones finales&#10;            try&#10;            {&#10;                if (tm != null)&#10;                {&#10;                    tm.onTransitionCutPointReached += onCut;&#10;                    tm.onTransitionEnd += onEnd;&#10;                }&#10;            }&#10;            catch (System.Exception ex) { Debug.LogException(ex); }&#10;&#10;            // Esperamos activamente a que la transición complete su flujo (cut o end)&#10;&#10;            try&#10;            {&#10;                Debug.Log($&quot;SceneTransitionLoader: Requesting Transition for {sceneName} (delay={delay})&quot;);&#10;                // Usar la sobrecarga que carga la escena internamente para evitar duplicar la carga&#10;                tm.Transition(sceneName, settings, delay);&#10;            }&#10;            catch (System.Exception ex)&#10;            {&#10;                // Si por alguna razón la llamada a Transition falla, hacemos fallback seguro&#10;                Debug.LogWarning(&quot;SceneTransitionLoader: Transition failed; loading scene directly.&quot;);&#10;                Debug.LogException(ex);&#10;                // nos aseguramos de desuscribir handlers que pudimos haber añadido&#10;                try&#10;                {&#10;                    if (tm != null)&#10;                    {&#10;                        if (onCut != null) tm.onTransitionCutPointReached -= onCut;&#10;                        if (onEnd != null) tm.onTransitionEnd -= onEnd;&#10;                    }&#10;                }&#10;                catch (System.Exception ex2) { Debug.LogException(ex2); }&#10;&#10;                if (!sceneLoaded)&#10;                {&#10;                    Debug.Log($&quot;SceneTransitionLoader: Loading scene (fallback after exception): {sceneName}&quot;);&#10;                    SceneManager.LoadScene(sceneName);&#10;                    sceneLoaded = true;&#10;                }&#10;&#10;                yield break;&#10;            }&#10;&#10;            // Esperamos a que la transición termine (cut o end). Esto evita que _isLoading se libere&#10;            // inmediatamente y que se inicien transiciones dobles.&#10;            float waitForTransitionTimeout = 10f; // segundos máximos de espera&#10;            float waitAcc = 0f;&#10;            while (!completed &amp;&amp; waitAcc &lt; waitForTransitionTimeout)&#10;            {&#10;                yield return null;&#10;                waitAcc += Time.unscaledDeltaTime;&#10;            }&#10;&#10;            if (!completed)&#10;            {&#10;                Debug.LogWarning(&quot;SceneTransitionLoader: Transition did not complete within timeout; forcing scene load.&quot;);&#10;                if (!sceneLoaded)&#10;                {&#10;                    SceneManager.LoadScene(sceneName);&#10;                    sceneLoaded = true;&#10;                }&#10;            }&#10;&#10;        }&#10;        finally&#10;        {&#10;            // limpieza segura: desuscribimos por si queda alguno (es seguro hacer -= si no está suscrito)&#10;            try&#10;            {&#10;                if (tm != null)&#10;                {&#10;                    if (onCut != null) tm.onTransitionCutPointReached -= onCut;&#10;                    if (onEnd != null) tm.onTransitionEnd -= onEnd;&#10;                }&#10;            }&#10;            catch { }&#10;            _isLoading = false;&#10;        }&#10;    }&#10;&#10;    static TransitionManager FindTM()&#10;    {&#10;    #if UNITY_2022_3_OR_NEWER&#10;        return Object.FindFirstObjectByType&lt;TransitionManager&gt;(FindObjectsInactive.Include);&#10;    #else&#10;        return Object.FindObjectOfType&lt;TransitionManager&gt;(true);&#10;    #endif&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>